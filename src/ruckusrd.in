#!/bin/bash
#
# ruckusrd - a super awesome, yet simple, mkinitrd replacement
#
# Copyright 2012 Michael D Labriola <michael.d.labriola@gmail.com>
#
# Licensed under the GPLv3. See the file COPYING for details. 
#
# This script is a derivative of fedora's livecd-creator's mayflower script,
# written by David Zeuthen <davidz@redhat.com>.
#
# It's been largely rewritten to be a mkinitrd replacement that can be used on
# embedded systems, flash drives, live CDs, and normal desktop Linux systems.
# See the file README for details.

VERSION="@VERSION@"

# check cwd so we don't accidentally use an installed version while we're
# developing
if [ -f linuxrc ]; then
    LINUXRC=$PWD/linuxrc
else
    LINUXRC=@LINUXRC@
fi


decho()
{
    if [ "$opt_verbose" != "0" ]; then
        echo "$*"
    fi
}


usage() {
    echo "ruckusrd v$VERSION - a super awesome, yet simple, mkinitrd replacement"
    echo
    echo "usage: $(basename $0) [--help] [--verbose] [--version] [-f] <out-initrd-image> <kernel-version>"
    echo
    echo "example: $(basename $0) /boot/myinitramfs.img \`uname -r\`"
}


opt_allow_overwrite=0
opt_verbose=0
INITRAMFS_TARGET=""
KERNEL=""
while [ $# -gt 0 ] ; do
    case $1 in
        --help)
            usage
            exit 0
            ;;
	-V|--version)
	    echo v$VERSION
	    exit 0
	    ;;
        -f)
            opt_allow_overwrite=1
            ;;
        -v|--verbose)
            opt_verbose=1
            ;;
        *)
            if [ -z "$INITRAMFS_TARGET" ] ; then
                INITRAMFS_TARGET=$1
            elif [ -z "$KERNEL" ] ; then
                KERNEL=$1
            else
                echo "Unknown option or parameter \"$1\""
                echo
                usage
                exit 1
            fi
            ;;
        *)
            ;;
    esac

    shift
done

if [ -z "$INITRAMFS_TARGET" -o -z "$KERNEL" ] ; then
    usage
    exit 1
fi

if [  "$opt_allow_overwrite" == "0" ] ; then
    if [ -e $INITRAMFS_TARGET ] ; then
	echo "Image $INITRAMFS_TARGET already exists. Use -f to overwrite"
	exit 1
    fi
fi

echo "Building an initramfs at $INITRAMFS_TARGET for kernel $KERNEL"

HOSTMODDIR=/lib/modules/$KERNEL/kernel
DESTMODDIR=lib/modules/$KERNEL

original_pwd=$PWD

TEMPDIR=`mktemp -d` || exit 1
decho TEMPDIR: $TEMPDIR
pushd $TEMPDIR > /dev/null
mkdir initramfs_dir
cd initramfs_dir

# Make directory structure 
#
# NOTE: We're just going to copy all our binaries into bin and ceate sbin as a
#       compatability symlink incase something explicitly calls somethings from
#       /sbin (e.g., /sbin/modprobe).
mkdir -p bin dev sys proc $DESTMODDIR sysroot etc/udev/rules.d lib/udev/rules.d

# Generate a list of binaries to copy into our filesystem
#
# NOTE: We have configure check for all these binaries and substitute their
#       paths into this list.  The upside to this is that we already know
#       exactly which binaries are on the system and where they're located.
#       The downside of this is that new versions of programs installed in
#       different locations will not get pulled into the initrd, even if they
#       come first in PATH.
#
# NOTE: We're just going to copy all of these into bin.  There's really no point
#       in differentiating between /bin and /sbin in the initramfs.
PROGS=""
PROGS+=" @BASENAME@"
PROGS+=" @BASH_SHELL@"
PROGS+=" @BLOCKDEV@"
PROGS+=" @CAT@"
PROGS+=" @CHMOD@"
PROGS+=" @CUT@"
PROGS+=" @DD@"
PROGS+=" @DIRNAME@"
PROGS+=" @DMESG@"
PROGS+=" @DMSETUP@"
PROGS+=" @ECHO@"
PROGS+=" @ENV@"
PROGS+=" @GREP@"
PROGS+=" @INSMOD@"
PROGS+=" @KILL@"
PROGS+=" @KILLALL5@"
PROGS+=" @LESS@"
PROGS+=" @LN@"
PROGS+=" @LOSETUP@"
PROGS+=" @LS@"
PROGS+=" @LSMOD@"
PROGS+=" @LVM@"
PROGS+=" @MDADM@"
PROGS+=" @MKDIR@"
PROGS+=" @MKNOD@"
PROGS+=" @MODPROBE@"
PROGS+=" @MOUNT@"
PROGS+=" @PIDOF@"
PROGS+=" @READLINK@"
PROGS+=" @RM@"
PROGS+=" @SED@"
PROGS+=" @SLEEP@"
PROGS+=" @TREE@"
PROGS+=" @UDEVD@"
PROGS+=" @UDEVADM@"
PROGS+=" @UMOUNT@"
PROGS+=" @VI@"
PROGS+=" @VOL_ID@"
PROGS+=" @SWITCH_ROOT@"

# Copy all the PROGS into the initramfs
decho '********** COPYING PROGS TO INITRAMFS ******************************************'
cp="cp"
[ "$opt_verbose" != "0" ] && cp+=" -v"
for x in $PROGS; do
    $cp $x bin/ || exit 1
done

# Make a couple symlinks
decho '********** MAKING SYMLINKS *****************************************************'
ln="ln"
[ "$opt_verbose" != "0" ] && ln+=" -v"
$ln -s bash bin/sh
$ln -s bin sbin
$ln -s ../../sbin/vol_id lib/udev/vol_id

# Copy all required shared libs
decho '********** COPYING NEEDED LIBS TO INITRAMFS ************************************'
for i in bin/*; do 
    ldd $i | sed 's|.*=>||g' | awk '/\// { print $1 }' >> libs 2>/dev/null
done

DEPLIBS=`cat libs | sort -u`
rm -f libs

for f in $DEPLIBS; do
    $cp $f lib/ || exit 1
done

# FIXME: should probably allow users to add more modules somehow, maybe a
#        command line arg or a conf file...

# Copy over ATA drivers
decho '********** COPYING ATA DRIVERS TO INITRAMFS ************************************'
find $HOSTMODDIR/drivers/ata -name \*.ko -exec $cp {} $DESTMODDIR/ \;

# NOTE: if we ever want to add DRM drivers as well (potentially for early KMS
#       fbcon splash screen), just uncomment the following lines
#
#decho '********** COPYING DRM DRIVERS TO INITRAMFS ************************************'
#find $HOSTMODDIR/drivers/gpu/drm -name \*.ko -exec $cp {} $DESTMODDIR/ \;

# Make sure none of the MODS we've installed have unmet dependencies
decho '********** COPYING MODULE DEPS TO INITRAMFS ************************************'
for m in $DESTMODDIR/*.ko ; do
    /sbin/modprobe --set-version $KERNEL --show-depends $m >> modules 2>/dev/null
done

DEPMODS=`cat modules | awk '{ print $2 }' | sort -u`
rm -f modules

for f in $DEPMODS; do
    $cp $f $DESTMODDIR/ || exit 1
done

# Build module deps file so we can use modprobe
decho '********** RUNNING DEPMOD ******************************************************'
go="/sbin/depmod -b `pwd` -v $KERNEL"
[ "$opt_verbose" != "1" ] && go+=" > /dev/null"
decho $go
eval $go || exit 1

# Write fstab
cat > etc/fstab <<EOF
/dev/root  /         auto    defaults,noatime  0 0
devpts     /dev/pts  devpts  gid=5,mode=620    0 0
tmpfs      /dev/shm  tmpfs   defaults          0 0
proc       /proc     proc    defaults          0 0
sysfs      /sys      sysfs   defaults          0 0
EOF

# FIXME: Most mkinitrd scripts I've looked at copy /etc/modprobe.conf and
#        /etc/modprobe.d from the host system to the initramfs...  My initial
#        testing indicates that this is not necesary, so I'm not going to do it.
#
# Copy modprobe.conf and friends over
#if [ -e /etc/modprobe.conf ] ; then
#    cp /etc/modprobe.conf etc
#fi
#cp -R /etc/modprobe.d etc


# Install our iniramfs' init script
decho '********** COPYING LINUXRC TO INITRAMFS ****************************************'
$cp $LINUXRC init || exit 1
chmod a+x init

[ "$opt_verbose" != "0" ] && tree -psugDFCa .

# Strip debug info
decho '********** STRIPPING UNNEEDED SYMBOLS FROM IMAGE *******************************'
go="find bin lib -type f -exec strip --strip-unneeded {} \;"
[ "$opt_verbose" != "1" ] && go+=" 2>/dev/null"
decho $go
eval $go

# Create the compressed image
decho '********** CREATING COMPRESSED CPIO IMAGE **************************************'
cpio="cpio"
[ "$opt_verbose" != "1" ] && cpio+=" --quiet"
find . | $cpio -o -H newc | gzip -9 > ../initramfs || exit 1
popd > /dev/null
rm -f $INITRAMFS_TARGET
$cp $TEMPDIR/initramfs $INITRAMFS_TARGET
rm -rf $TEMPDIR

echo "Done; initramfs is $(du -h $INITRAMFS_TARGET | awk '{print $1}')."
echo
exit 0
