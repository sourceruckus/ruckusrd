#!/bin/bash
#
# Copyright 2012-2024 Michael D Labriola <veggiemike@sourceruckus.org>
#
# Licensed under the GPLv3. See the file COPYING for details. 
#
# This script should get executed by the build system to create lower.sqsh,
# which should get installed by the install target.

. ruckusrd.sh

# make sure we're starting clean
rm -rf initramfs initramfs.cpio.xz

# Make directory structure
#
# NOTE: We're just going to create bin and ceate sbin as a compatability
#       symlink if it doesn't exist later on in case something explicitly calls
#       somethings from /sbin (e.g., /sbin/modprobe).
#
# NOTE: Same goes for /usr/bin, /usr/sbin, and /usr/lib.
#
echo '********** MAKING DIRECTORIES **************************************************'
mkdir -vp initramfs/{bin,dev,sys,proc,usr,run,sysroot,etc,lib} || exit 1


# Make a couple symlinks
echo '********** MAKING SYMLINKS *****************************************************'
ln -vs bin initramfs/sbin &&
ln -vs ../bin initramfs/usr/bin &&
ln -vs ../sbin initramfs/usr/sbin &&
ln -vs ../lib initramfs/usr/lib &&
ln -vs ../lib64 initramfs/usr/lib64 &&
# Fixup lib vs lib64
#
# NOTE: We symlink lib64->lib here to ensure that our runtime linker works on
#       x86, x86_64 multilib, and pure64.  There does exist the possibility
#       that we're copying in binaries with conflicting runtime libs, though
#       (e.g., say mdadm is 32bit on host system, it will put the 32bit
#       libc.so.6 in /lib which will break all the 64bi binaries...).
#
ln -vs lib initramfs/lib64 || exit 1


# Copy all the PROGS into the initramfs
echo '********** COPYING PROGS TO INITRAMFS ******************************************'
for x in ../subprojects/{busybox,util-linux,eudev,mdadm,lvm2,e2fsprogs,squashfs-tools,zfs,syslinux,dropbear,rsync,efibootmgr,groff,zstd,less,fsarchiver}.tar; do
    # NOTE: We use --keep-old-files here to prevent replacement of
    #       usr/{bin,sbin,lib,lib64} symlnks.  It would be nice if we could
    #       find a better way to do that, while allowing us to overwrite
    #       busybox symlinks.  Until then, we'll untar busybox last and tweak
    #       it's build to remove unneeded symlinks.
    tar -C initramfs --keep-old-files -vxf $x || exit 1
done


# Copy all required shared libs
echo '********** COPYING NEEDED LIBS TO INITRAMFS ************************************'
DEPLIBS=$(LD_LIBRARY_PATH=initramfs/lib find initramfs -type f -exec ldd {} 2>/dev/null \; \
    | sed 's|.*=>||g' | awk '/\// { print $1 }' | sort | uniq)
#
# NOTE: Deref symlinks, otherwise we'll end up with a bunch of broken symlinks
#       instead of actual libraries for every single lib.
#
# NOTE: At least on Ubuntu 18.04, libgcc_s.so is needed at runtime by
#       mksquashfs (so it can pthread_cancel) on the initramfs, but nothing
#       explicitly links against it so it's left out here...
#
# NOTE: Same situation for Glibc's NSS runtime shared libs.  Gotta grab them.
#
for f in $DEPLIBS; do
    if [ ! -f initramfs/lib/$(basename $f) ]; then
        cp -va --dereference $f initramfs/lib/ || exit 1
    fi
    # grab ligbcc_s.so if it exists in the same dir as libpthread.so
    if (echo $f | grep -q libpthread); then
        gcc_s=$(dirname $f)/libgcc_s.so.*
        echo GCC_S: $gcc_s
        if [ -n "$gcc_s" ]; then
            cp -va --dereference $gcc_s initramfs/lib/ || exit 1
        fi
    fi
    # grab all the nss libs if they exist in the same dir as libc.so
    if (echo $f | grep -q libc.so); then
        nss=$(dirname $f)/libnss*.so.*
        echo NSS: $nss
        if [ -n "$nss" ]; then
            cp -va --dereference $nss initramfs/lib/ || exit 1
        fi
    fi
done


# Remove static libs
echo '********** REMOVING UNNEEDED FILES *********************************************'
go="find initramfs \( -type f -a -name \*.h \) -exec rm -v --interactive=never {} \;"
echo $go
eval $go
go="find initramfs \( -type f -a -name \*.a \) -exec rm -v --interactive=never {} \;"
echo $go
eval $go
go="find initramfs \( -type f -a -name \*.la \) -exec rm -v --interactive=never {} \;"
echo $go
eval $go


# Strip debug info
#
# NOTE: We have to chmod a couple files to allow strip to work.  We re-chmod to
#       original settings afterwards.
#
echo '********** STRIPPING UNNEEDED SYMBOLS FROM IMAGE *******************************'
chmod +w initramfs/bin/{dmsetup,lvm} initramfs/lib/libdevmapper.so.*
go="find initramfs \( -type f -a -perm /111 \) -exec strip --strip-unneeded {} \;"
echo $go
eval $go
chmod -w initramfs/bin/{dmsetup,lvm} initramfs/lib/libdevmapper.so.*


# Uncompress manpages
#
# NOTE: The entire nitramfs is compressed, so we uncompress compressed files
#       here.
#
echo '********** UNCOMPRESSING FILES (because entire initramfs gets compressed) ******'
go="find initramfs \( -type f -a -name \*.gz \) -exec gunzip -v {} \;"
echo $go
eval $go
go="find initramfs \( -type f -a -name \*.xz \) -exec unxz -v {} \;"
echo $go
eval $go


# Copy modprobe.conf and friends over
#
# NOTE: For a while, we did not do this, in an effor to keep the initrd as
#       generic as possible.  However, now that we're loading potentually tons
#       of modules via udev during initrd stage, we probably want to do this.
#       Otherwise, carefully written distro modprobe.conf files will have no
#       effect.  For the record, my review of the Ubuntu 18.04 and 20.04
#       modprobe configs makes it look like mostly generic blacklisting of
#       known problem modules (e.g., old modules that have been replaced by new
#       drivers but the old one is still around).
#
echo '********** COPYING HOST SYSTEM MODPROBE CONFIG *********************************'
if [ -e /etc/modprobe.conf ] ; then
    go="cp -vL /etc/modprobe.conf initramfs/etc"
    echo $go
    eval $go
fi
if [ -d /etc/modprobe.d ]; then
    go="cp -vLR /etc/modprobe.d initramfs/etc"
    echo $go
    eval $go
fi

# Write fstab
echo '********** GENERATING FSTAB ****************************************************'
cat > initramfs/etc/fstab <<EOF
/dev/root  /         auto    defaults,noatime  0 0
devpts     /dev/pts  devpts  gid=5,mode=620    0 0
tmpfs      /dev/shm  tmpfs   defaults          0 0
proc       /proc     proc    defaults          0 0
sysfs      /sys      sysfs   defaults          0 0
EOF

# Create passwd and group
#
# NOTE: We can't login via getty or ssh if we don't at least define a
#       passwordless root account.
#
echo '********** GENERATING PASSWD/GROUP *********************************************'
cat > initramfs/etc/shells <<EOF
/bin/ash
/bin/bash
EOF
cat > initramfs/etc/passwd <<EOF
root::0:0:root:/root:/bin/ash
bin:x:1:1:bin:/bin:/bin/false
daemon:x:2:6:daemon:/sbin:/bin/false
ruckus::1000:1000:RuckusRD User:/home/ruckus:/bin/ash
nobody:x:65534:65533:Unprivileged User:/dev/null:/bin/false
EOF
cat > initramfs/etc/group <<EOF
root:x:0:
bin:x:1:
sys:x:2:
kmem:x:3:
tape:x:4:
tty:x:5:
daemon:x:6:
floppy:x:7:
disk:x:8:
lp:x:9:
dialout:x:10:
audio:x:11:
video:x:12:
utmp:x:13:
usb:x:14:
cdrom:x:15:
adm:x:16:
console:x:17:
cdrw:x:18:
mail:x:30:
news:x:31:
wheel:x:39:
users:x:1000:
nogroup:x:65533:
EOF
chmod -v 644 initramfs/etc/{passwd,group}
mkdir -p initramfs/home/ruckus
chown 1000:1000 initramfs/home/ruckus


# Write inittab
#
# NOTE: This is only needed for the `ruckusonly` embedded system
echo '********** GENERATING INITTAB **************************************************'
cat > initramfs/etc/inittab <<EOF
# NOTE: Normally, rcS would mount virtual filesystems, prepopulate /dev, start
#       udev, etc.  This is all done elsewhere inside linuxrc, so we don't even
#       call an rcS script.
#
#::sysinit:/etc/init.d/rcS

# /sbin/getty invocations for selected ttys
#
# FIXME: Not sure what the baud rate should be, or if it even matters on a
#        non-serial tty.
#
# NOTE: These are completely pointless if we're booting up as a Xen domU... but
#       having them here doesn't seem to hurt anything and they are helpful if
#       you're actually booting up on real hardware.
#
# FIXME: i don't specify tty a the beginning, to autodect, but then i do
#        specify tty at the end because getty needs that argument...?
#
#::respawn:/sbin/getty 38400 tty1
#tty2::respawn:/sbin/getty 38400 tty2
#tty3::respawn:/sbin/getty 38400 tty3
#tty4::respawn:/sbin/getty 38400 tty4
#tty5::respawn:/sbin/getty 38400 tty5
#tty6::respawn:/sbin/getty 38400 tty6
#
# FIXME: askfirst vs getty... which do i want?  askfirst is certainly simpler,
#        doesn't take a baud or tty argument, and i really only have a root
#        user... so is there any reason to do getty?
#
# Start an "askfirst" shell on the console (whatever that may be)
::askfirst:-/bin/sh
# Start an "askfirst" shell on /dev/tty2-4
tty2::askfirst:-/bin/sh
tty3::askfirst:-/bin/sh
tty4::askfirst:-/bin/sh
# /sbin/getty invocations for selected ttys
tty5::respawn:/sbin/getty 38400 tty5
tty6::respawn:/sbin/getty 38400 tty6

# Serial console (example only!)
#
# FIXME: This is messing with the Xen hvc0 console for some reason.  Only
#        enable this if you have a serial line and you're not using Xen.
#
#::respawn:/sbin/getty -L ttyS0 115200 vt100

# Stuff to do when restarting the init process
::restart:/sbin/init

# Stuff to do before rebooting
::ctrlaltdel:/sbin/reboot
::shutdown:/bin/umount -a -r
::shutdown:/sbin/swapoff -a
EOF


# Install our initramfs init script
echo '********** COPYING LINUXRC TO INITRAMFS ****************************************'
install -vp linuxrc initramfs/init &&
cp -va ruckusrd.sh initramfs/ || exit 1


# Make a couple extra symlinks, if needed
echo '********** MAKING CONDITIONAL SYMLINKS *****************************************'
[ ! -f initramfs/bin/bash ] && (ln -vs sh initramfs/bin/bash || exit 1)


# Bail if we've created any broken symlinks
echo '********** CHECKING FOR BROKEN SYMLINKS ****************************************'
# NOTE: Using 'find initramfs -xtype l' really only works for relative
#       links... absolute paths are being checked against the host system, not
#       the initramfs.  So we have to do it by hand with some careful path
#       manipulation.
#
# NOTE: Also, we touch /dev/null here to avoid failures with links pointing to
#       non-existent /dev/null.  We cannot create /dev/null w/out root
#       privileges, so we just create a normal file.  It will get overwritten
#       during boot.
#
touch initramfs/dev/null
links=$(find initramfs -type l)
blarg=
for l in $links; do
    t=$(readlink $l)
    #echo "$l -> $t"
    if (echo $t | grep -q "^/"); then
        #echo -n "ABSOLUTE, "
        checkit=initramfs$t
    else
        #echo -n "RELATIVE, "
        checkit=$(dirname $l)/$t
    fi
    #echo -n "checking for $checkit "
    if [ ! -e $checkit ]; then
        #echo FAILED
        blarg+=" $l"
    #else
    #    echo passed
    fi
done
if [ -n "$blarg" ]; then
    echo "ERROR: broken link(s) detected: $blarg"
    exit 1
fi


# Create initramfs.cpio.xz file
echo '********** CREATING CPIO ARCHIVE ***********************************************'
pushd initramfs &&
find . | cpio -v -o -H newc | xz -vzc --check=crc32 > ../initramfs.cpio.xz &&
popd || exit 1
