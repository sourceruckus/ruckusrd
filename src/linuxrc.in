#!/bin/bash
#
# Copyright 2012-2018 Michael D Labriola <michael.d.labriola@gmail.com>
#
# Licensed under the GPLv3. See the file COPYING for details. 
#
# This initramfs /init script is a derivative of the one embedded in mayflower
# (flexible mkinitrd replacement used originally by fedora's livecd-creator,
# David Zeuthen <davidz@redhat.com>).
#
# It's been largely rewritten to be used as the initramfs /init script for a
# mkinitrd replacement that can be used on embedded systems, flash drives, live
# CDs, and normal desktop Linux systems.  See the file README for details.
#
# NOTE: At the moment, and this might change, we're not loading KMS video
#       drivers in here.  I was planning on doing just that, but I couldn't
#       quite get things working the way I wanted.
#
#       For example, using nouveau on one of our old dual-Xeons, even if the
#       very fist line of the script is 'modprobe nouveau', you don't get
#       penguin logos.  However, if nouveau is actually built into the kernel,
#       you get penguins a split second after booting starts, but you also get a
#       big white box that obscures some of the output.  So the best way to
#       ensure you get the penguin logos appears to still be to set
#       vga=something to initialize the vga framebuffer for a few seconds before
#       the KMS video driver gets loaded.  And If we do that and then load the
#       KMS driver in the initrd, you get two modesets within a 1-2 second
#       window... which just looks strange.
#
#       If we ever decide to play with plymouth or some other nice splash screen
#       utility, we might want to revisit this and just ditch the penguin logos
#       (although I kinda like being able to see right off the bat how many CPUs
#       have been detected).
#
# ---- BUSYBOX COMPAT NOTE ----
# So far, this script uses the following non-basic features that I should
# double-check for busybox applet compatibility moving forward:
#
# - sed -i
# - bash ${param#word} and ${param//#pattern/string} expansions
# - bash trap
# - bash $() command subst
# - bash {} globbing (e.g., cp foo{,bak})
# - bash var+=


# a couple substitutions
have_mdadm=@have_mdadm@
have_lvm=@have_lvm@
have_blkid=@have_blkid@
have_vol_id=@have_vol_id@
have_udevadm=@have_udevadm@
have_udevstart=@have_udevstart@


decho()
{
    if [ "$quiet" != "1" ]; then
        echo "$*"
    fi
}


do_raid_and_lvm()
{
    # wait for at least one harddisk to be handled by udev
    #
    # NOTE: this is needed because this method might be called before we can
    #       guarantee that udev has finished loading modules.
    x=$1
    msg="waiting up to $x seconds for at least one hdd to appear..."
    while [ ! -e /dev/sda -a "$x" != "0" ]; do
        if [ -n "$msg" ]; then
            echo -n $msg
            msg=""
        else
            echo -n "."
        fi
        x=$(($x-1))
        sleep 1
    done
    [ -z "$msg" ] && echo " done"

    # if we were asked to wait, wait another second
    #
    # NOTE: this should make it almost impossible to fail to detect devices due
    #       to concurrency problems.  the only way for it to happen now is if
    #       /dev/sda *JUST* got created when the previous waitloop started (so
    #       we don't wait at all), but we get to this 2nd conditional before
    #       /dev/sdb has been created.
    [ "$1" != "0" ] && sleep 1

    if [ "$have_mdadm" != "0" ]; then
        # autogen mdadm.conf
	echo 'DEVICE /dev/sd*[0-9]' > /etc/mdadm.conf
	mdadm --examine --scan | sed 's|/dev/.tmp.|/dev/|' >> /etc/mdadm.conf
	[ "$quiet" != "1" ] && cat /etc/mdadm.conf

	grep ARRAY /etc/mdadm.conf >/dev/null && raid=1 || raid=0
	if [ "$raid" != "0" ]; then
            echo "initializing RAID devices..."
            go="mdadm --assemble --scan"
            [ "$quiet" != "1" ] && go="$go -v"
            decho $go
            eval $go || echo "WARNING: RAID initialization failed"
	fi
    fi

    if [ "$have_lvm" != "0" ]; then
	echo "initializing LVM..."

	go="lvm vgscan --mknodes"
	[ "$quiet" != "1" ] && go="$go -v"
	decho $go
	eval $go || echo "WARNING: LVM initialization failed"

	go="lvm vgchange -a y"
	[ "$quiet" != "1" ] && go="$go -v"
	decho $go
	eval $go || echo "WARNING: LVM initialization failed"
    fi
}


emergency_shell()
{
    echo "Bug in initramfs /init detected. Dropping to a shell. Good luck!"
    echo
    bash
}


# This method creates udev rules such that we end up with a /dev/$1 symlink
# that points to the device specified by $2, which can be CDLABEL, LABEL, UUID,
# or an actual device name (e.g., /dev/sda1, /dev/md0, /dev/mapper/vg0_lv1).
#
# NOTE: We try to depend on the hotplug implementation as little as possible in
#       here (i.e., we're leaving the door open for mdev as much as possible).
#
# NOTE: This method modifies the following important global variables:
#
#       thingtomount: argument to be mounted for root filesys
#
#       dmroot: set to 1 if thingtomount requires device mapper
generate_udev_rules()
{
    name=$1
    str=$2

    # blkid vs vol_id compatibility
    if [ "$have_blkid" != "0" ]; then
	get_label="/sbin/blkid -o value -s LABEL"
	get_uuid="/sbin/blkid -o value -s UUID"
    else
	get_label="/sbin/vol_id -l"
	get_uuid="/sbin/vol_id -u"
    fi

    # NOTE: we're assuming SCSI device nodes here, now that SATA, PATA, USB, and
    #       SCSI should all be using them.
    case $str in
        CDLABEL=*)
            CDLABEL=${str#CDLABEL=}
            echo "KERNEL==\"sr[0-9]\", PROGRAM=\"$get_label %N\", RESULT==\"$CDLABEL\", SYMLINK+=\"$name\"" >> /etc/udev/rules.d/00-cdlabel.rules
            echo "KERNEL==\"scd[0-9]\", PROGRAM=\"$get_label %N\", RESULT==\"$CDLABEL\", SYMLINK+=\"$name\"" >> /etc/udev/rules.d/00-cdlabel.rules
            decho "Added udev rule for CDLABEL=='$CDLABEL'"
            if [ "$name" = "root" ]; then
                thingtomount=/dev/root
                dmroot=0
            fi
            ;;
        LABEL=*)
            LABEL=${str#LABEL=}
            echo "SUBSYSTEM==\"block\", PROGRAM=\"$get_label %N\", RESULT==\"$LABEL\", SYMLINK+=\"$name\"" >> /etc/udev/rules.d/00-label.rules
            decho "Added udev rule for LABEL=='$LABEL'"
            if [ "$name" = "root" ]; then
                thingtomount=/dev/root
                dmroot=1
            fi
            ;;
        UUID=*)
            UUID=${str#UUID=}
            echo "SUBSYSTEM==\"block\", PROGRAM=\"$get_uuid %N\", RESULT==\"$UUID\", SYMLINK+=\"$name\"" >> /etc/udev/rules.d/01-uuid.rules
            decho "Added udev rule for UUID=='$UUID'"
            if [ "$name" = "root" ]; then
                thingtomount=/dev/root
                dmroot=1
            fi
            ;;
        /dev/md*|/dev/V*|/dev/mapper/*)
            ln -fs $str /dev/$name
            if [ "$name" = "root" ]; then
                thingtomount=$str
                dmroot=1
            fi
            ;;
        /dev/*)
            ln -fs $str /dev/$name
            if [ "$name" = "root" ]; then
                thingtomount=$str
                dmroot=0
            fi
            ;;
        *)
            if [ "$name" = "root" ]; then
                thingtomount=$str
                dmroot=0
            fi
            ;;
    esac
}


trap "emergency_shell" 0 2

# exit immediately if a command fails
set -e

PATH=/sbin:/bin

exec < /dev/console > /dev/console 2>&1

# mount tmpfs for /dev
mount -n -t tmpfs -o mode=0755 udev /dev

# create initial device nodes
mknod /dev/console c 5 1
mknod /dev/null c 1 3
mknod /dev/kmsg c 1 11
mkdir /dev/pts
mkdir -m 1777 /dev/shm
ln -fs /proc/self/fd /dev/fd
ln -fs fd/0 /dev/stdin
ln -fs fd/1 /dev/stdout
ln -fs fd/2 /dev/stderr

# mount virtual filesystems
mount -n -t proc proc /proc
mount -n -t sysfs sysfs /sys

# create /etc/mtab symlink
ln -fs /proc/mounts /etc/mtab

# setup hotplug
echo "" > /proc/sys/kernel/hotplug

# Declare all variables here.. mostly for housekeeping
init="/sbin/init"
root="/dev/something"
root_rw=""
root_true_rw="ro"
rootflags=""
rootfstype="auto"
to_ram=""
maint=""
hoststamp=""
quiet=0
overlay_size="512M"
dmroot=0
squashfs="squashfs.img"
squashdev=""
sqsh_layers=""
sqsh_layerdev=""
sqsh_layerdir="/tmproot"
sqsh_layerdir_rel=""
ram_layer=""

# Parse kernel commandline options
#
# NOTE: By default, when this script hands off control the the underlying
#       root filesystem's init process, the rootfs will be mounted ro.  This
#       behavior can be overriden by passing 'rw' on the kernel command
#       line.
#
# NOTE: rootfstype, rootflags are only applied when mounting the specified root
#       device.  in other words, they are not used when mounting the derivative
#       devices created when we load rootfs into RAM.
for o in `cat /proc/cmdline` ; do
    case $o in 
    init=*)
        init=${o#init=}
        ;;
    quiet)
        quiet=1
        ;;
    to_ram)
        to_ram=1
	;;
    maint)
	maint=1
	;;
    rw)
        root_rw=1
        ;;
    root_true_rw)
        root_true_rw="rw"
        ;;
    hoststamp)
        hoststamp=1
        ;;
    blacklist=*)
        blacklist=${o#blacklist=}
        echo "blacklist $blacklist" >> /etc/modprobe.conf
        ;;
    root=*)
        root=${o#root=}
        ;;
    rootflags=*)
        rootflags=${o#rootflags=}
        ;;
    rootfstype=*)
        rootfstype=${o#rootfstype=}
        ;;
    overlay_size=*)
        overlay_size=${o#overlay_size=}
        ;;
    squashfs=*)
        squashfs=${o#squashfs=}
        ;;
    squashdev=*)
        squashdev=${o#squashdev=}
        ;;
    sqsh_layers=*)
        sqsh_layers=${o#sqsh_layers=}
        # make layers space-delimited for iterating
        sqsh_layers_ws=${sqsh_layers//:/ }
        ;;
    sqsh_layerdev=*)
        sqsh_layerdev=${o#sqsh_layerdev=}
        sqsh_layerdir=/sqsh_layerdev
        ;;
    sqsh_layerdir=*)
        sqsh_layerdir_rel=${o#sqsh_layerdir=}
        ;;
    ram_layer=*)
        ram_layer=${o#ram_layer=}
        ;;
    *)
        # NOTE: putting "loop.max_loop=16" in cmdline would cause "options loop
        #       max_loop=16" to get written in modprobe.conf...
        m=$(echo $o |cut -s -d . -f 1)
        opt=$(echo $o |cut -s -d . -f 2-)
        if [ -z "$m" -o -z "$opt" ]; then
          continue
        fi
        p=$(echo $opt |cut -s -d = -f 1)
        v=$(echo $opt |cut -s -d = -f 2-)
        if [ -z "$p" -o -z "$v" ]; then
          continue
        fi
        echo "options $m $p=$v" >> /etc/modprobe.conf
        ;;
    esac
done

# if user provided sqsh_layerdir, append it to the device mountpoint
if [ -n "$sqsh_layerdir_rel" ]; then
    sqsh_layerdir=$sqsh_layerdir/$sqsh_layerdir_rel
fi

decho "kernel commandline: `cat /proc/cmdline`"
decho "init=$init"
decho "root=$root"
decho "root_rw=$root_rw"
decho "root_true_rw=$root_true_rw"
decho "rootflags=$rootflags"
decho "rootfstype=$rootfstype"
decho "to_ram=$to_ram"
decho "maint=$maint"
decho "hoststamp=$hoststamp"
decho "overlay_size=$overlay_size"
decho "squashfs=$squashfs"
decho "squashdev=$squashdev"
decho "sqsh_layers=$sqsh_layers"
decho "sqsh_layerdev=$sqsh_layerdev"
decho "sqsh_layerdir=$sqsh_layerdir"
decho "sqsh_layerdir_rel=$sqsh_layerdir_rel"
decho "ram_layer=$ram_layer"

echo -n "determining what to mount... "

generate_udev_rules root $root
[ -n "$squashdev" ] && generate_udev_rules squashdev $squashdev
[ -n "$sqsh_layerdev" ] && generate_udev_rules sqsh_layerdev $sqsh_layerdev


echo "$thingtomount (dmroot=$dmroot)"

echo "udev_log=\"error\"" >> /etc/udev/udev.conf

# rules for loading modules
#
# FIXME: Originally (i.e., when I was using an ancient version of
#        udev), we were configuring udev to load modules right here by
#        injecting a single globular rule into /etc/udev/rules.d.
#        This was working fine until I started playing with a system
#        that used a version of udev that no longer installed
#        vol_id...  I've got a few options here.
#
#        1. Inject this rule if have_vol_id.  This will mimick what I
#           was already doing, but might conflict with the newly
#           populated /lib/udev/rules.d
#
#        2. Only inject if we haven't populated /lib/udev/rules.d.
#           This will ensure that we don't clobber the new rules, but
#           I know things were working before with the injected
#           modprobe rule...
#
# FIXME: I'm going with #2 for now.
#
# FIXME: No 1 is bad... if i have blkid, i don't even check for vol_id.  and
#        having blkid actually has no correlation with the version of udev
#        we're using.
if [ -z "$(ls -A /lib/udev/rules.d)" ]; then
    echo -n "ACTION==\"add\", SUBSYSTEM==\"?*\", ENV{MODALIAS}==\"?*\", RUN+=\"/sbin/modprobe $" >> /etc/udev/rules.d/10-modprobe.rules
    echo "env{MODALIAS}\"" >> /etc/udev/rules.d/10-modprobe.rules
fi

decho "starting udevd"
# FIXME: when did --resolve-names get added?  I know my old fedora 9
#        box didn't have that flag...
/sbin/udevd --daemon --resolve-names=never || \
    /sbin/udevd --daemon

# load loop module (if not built-in)
if [ -d /sys/module/loop ]; then
    loop_builtin=1
else
    loop_builtin=0
    modprobe loop
fi

# tell udevd to start processing its queue
#
# NOTE: We're maintaining (for now) compatibility for realy old versions of
#       udev, circa FC5, that used udevstart instead of udevadm (and had
#       slightly different behavior).
#
# FIXME: should I also "settle" in here?  that would wait until udev is done
#        emptying its queue... but we already have a timer loop later on.
if [ "$have_udevadm" != "0" ]; then
    /sbin/udevadm trigger

    if [ "$loop_builtin" != 0 ]; then
        # create loop devices
        #
        # NOTE: If loop was compiled in, then the module didn't get loaded,
        #       which means udev won't ever create the /dev/loop* device
        #       nodes.
        #
        # FIXME: This assumes that the device minor numbers increment by 1 per
        #        loop device, which can be untrue if loop was compiled with
        #        support for partitions.  I don't care right now.  Anyone
        #        actually building loop into their kernels AND changing the
        #        defaults will have to change the following for loop.
        for ((x=0; x<8; x++)); do
            mknod -m 660 /dev/loop$x b 7 $x
        done
    fi
else
    /sbin/udevstart

    # NOTE: Testing on old hardware with loop compiled into the kernel
    #       indicates that udevstart creates /dev/loop1-8 for us.
fi

# initialize LVM if needed now
#
# NOTE: We're asking the init method to wait up to 10 seconds for udev to load
#       modules for drive controllers before we kick off initialization of LVM.
#       Withouth the sleep, vgscan might run prior to the kernel noticing the
#       existance of the harddrive that contains the volgroup...
if [ "$dmroot" != "0" ]; then
    do_raid_and_lvm 10
fi

# wait for root symlink
#
# NOTE: this loop waits up to 30 seconds for /dev/root symlink to get created.
#       if it takes longer than that, something is wrong, but maybe the user can
#       fix it.
x=30
msg="waiting up to $x seconds for /dev/root symlink..."
while [ ! -e /dev/root -a "$x" != "0" ]; do
    if [ -n "$msg" ]; then
        echo -n $msg
        msg=""
    else
        echo -n "."
    fi
    x=$(($x-1))
    sleep 1
done
root_true=`readlink /dev/root`

# NOTE: At this point, either /dev/root exists OR our waitloop timed out.  We'll
#       give the user a chance to manually create the /dev/root symlink.
if [ -b /dev/root ] ; then
    [ -z "$msg" ] && echo " done"
    decho "/dev/root symlink exists ($root_true)"
else
    echo
    echo
    echo "--------------------------------------"
    echo "WARNING: Cannot find root file system!"
    echo "--------------------------------------"
    echo
    echo "Create symlink /dev/root and then exit this shell to continue"
    echo "the boot sequence."
    echo
    bash
fi

# run fsck on root dev
#
# NOTE: The root dev becomes impossible to unmount (and thus, impossible to
#       safely fsck) after we pass control over to the host os (unless we load
#       the whole image into RAM).
#
# NOTE: While we do care if this fails, we don't really want a failure to keep
#       the system from booting, especially since an exit status of 1 indicates
#       that fsck found AND SUCCESSFULLY FIXED some errors.
#
# NOTE: Obviously, running fsck on CD/DVD would be dumb.
#
# FIXME: We should really do better fsck error checking (see fsck(8) for exit
#        codes).
if ! (echo $root | grep -q CDLABEL); then
    go="fsck -TC $thingtomount"
    decho $go
    eval $go || echo "WARNING: fsck of rootdev exited non-zero"
fi

mountoptions=" -o ro"
if [ -n "$rootflags" ]; then
    mountoptions+=",$rootflags"
fi

go="mount -t $rootfstype $mountoptions $thingtomount /sysroot"
decho $go
eval $go
RES=$?

if [ "$RES" != "0" ] ; then
    echo "---------------------------------"
    echo "WARNING: Cannot mount rootfs!"
    echo "---------------------------------"
    echo
    echo "Dropping to a shell. "
    echo "Mount rootfs at /sysroot and exit shell to continue. Good luck!"
    echo
    bash
fi

# look for squashdev
if [ -h /dev/squashdev ]; then
    # NOTE: rootfstype and mountoptions do NOT follow the rootfs rules
    go="mkdir -p /squashdev && mount -t auto -o ro /dev/squashdev /squashdev"
    decho $go
    eval $go
    SQUASHED="/squashdev/$squashfs"
else
    SQUASHED="/sysroot/$squashfs"
fi

# look for sqsh_layerdev
if [ -h /dev/sqsh_layerdev ]; then
    # NOTE: rootfstype and mountoptions do NOT follow the rootfs rules
    go="mkdir -p /sqsh_layerdev && mount -t auto -o ro /dev/sqsh_layerdev /sqsh_layerdev"
    decho $go
    eval $go
fi

# only pass kernel command line if we're launching /sbin/init
if [ "$init" == "/sbin/init" ] ; then
    initargs=$(cat /proc/cmdline)
else
    initargs=""
fi

# initialize device mapper and LVM
#
# NOTE: This was already done at the very beginning if root was specified as
#       /dev/mapper/*.  We're going to do it now if it hasn't already been done,
#       just so we can assume from here on out that the device mapper and LVM
#       have been initialized.
#
# NOTE: We tell the init method to not wait for devices at this point, assuming
#       that udev has had plenty of time to create device nodes.
if [ "$dmroot" != "1" ]; then
    do_raid_and_lvm 0
fi


# do prep for squashfs magic common to both old device-mapper and new overlayfs
# implementations
if [ -n "$sqsh_layers" ] || [ -f $SQUASHED ]; then
    decho "doing common squashfs prep"

    ln -s $root_true /dev/root-true

    # move /sysroot out of the way so we can still access it
    mkdir /tmproot
    decho "moving /sysroot to /tmproot"
    mount --move /sysroot /tmproot

    # update this variable to point into /tmproot (unless we're using a
    # squashdev)
    if [ -z "$squashdev" ]; then
        SQUASHED="/tmproot/$squashfs"
    fi
fi

# squashfs magic time
if [ -n "$sqsh_layers" ]; then
    # do new OverlayFS based stuff
    decho "setting up OverlayFS squashfs layers"

    # copy to ram if requested
    if [ -n "$to_ram" ]; then
        echo -n "Copying squashfs layer(s) to RAM... "
        decho ""
        go="cp -a"
        [ "$quiet" != "1" ] && go+=" -v"
        for x in $sqsh_layers_ws; do
            go+=" $sqsh_layerdir/$x.sqsh"
        done
        go+=" /"
        decho $go
        eval $go
	echo "done"
        sqsh_layerdir=/
    fi

    # mount individual layers
    #
    # NOTE: We create /dev symlinks here to disguise the loopback device.
    #       W/out it, some systems attempt to unmount loop devices prior to
    #       other filesystems, which leads to problems.
    #
    #       we won't have to worry pre-switchroot paths being incorrect once we
    #       swithcroot.
    #
    # FIXME: are these /dev symlinks still around after switchroot runs its own
    #        udev stuff?
    #
    for x in $sqsh_layers_ws; do
        loopdev=$(losetup -f)
        losetup $loopdev $sqsh_layerdir/$x.sqsh
        ln -s $loopdev /dev/sqsh_layer-$x
        mkdir -p /sqsh_layer-$x
        go="mount -o ro /dev/sqsh_layer-$x /sqsh_layer-$x"
        decho $go
        eval $go
    done

    # create ram layer if requested
    if [ -n "$ram_layer" ]; then
        decho "creating ram_layer w/ size=$ram_layer"
        mkdir -p /upper
        mount -t tmpfs -o size=$ram_layer ram_layer /upper
        mkdir -p /upper/{upper,work}
        upper=upper
    else
        # need to remount rootfs rw so we can write into upper layer
        decho "remounting /tmproot rw"
        mount -o remount,rw /tmproot
        mkdir -p /tmproot/upper/{upper,work}
        upper=/tmproot/upper
        # if we're not using ram_layer, we cannot remount sysroot ro later on,
        # so we must change this flag to rw
        root_true_rw=rw
    fi

    # mount the merged filesystem
    decho "mounting overlayfs at /sysroot"
    lower=/sqsh_layer-${sqsh_layers//:/:/sqsh_layer-}
    overlayflags=lowerdir=$lower,upperdir=$upper/upper,workdir=$upper/work
    decho "lower: $lower"
    decho "upper: $upper"
    mount -t overlay -o $overlayflags rootfs /sysroot

elif [ -f $SQUASHED ]; then
    # NOTE: if $SQUASHED exists, the system we're attempting to boot has been
    #       set up with a squashfs read-only rootfs image to be used with a
    #       writable overlay using some device mapper voodoo
    #
    # NOTE: additionally, $SQUASHED can be loaded into RAM to free up the
    #       underlying root device (excellent for booting off removable media
    #       on systems with enough RAM to handle such a thing.
    #
    decho "setting up squashfs device mapper voodoo"

    if [ -n "$to_ram" ]; then
	echo -n "Copying compressed rootfs image to RAM... "
	dd if=$SQUASHED of=/squashed.img bs=512 2> /dev/null
	echo "done"
	SQUASHED="/squashed.img"
    fi

    SQUASHED_LOOPDEV=$( losetup -f )
    losetup $SQUASHED_LOOPDEV $SQUASHED
    mkdir -p /squashfs
    mount -t squashfs -o ro $SQUASHED_LOOPDEV /squashfs

    BASE_LOOPDEV=$( losetup -f )
    losetup $BASE_LOOPDEV /squashfs/rootfs.img

    umount -l /squashfs

    # create a sparse file for the overlay
    #
    # NOTE: this uses our overlay_size variable, which can be set on the command
    #       line. we do no syntax checking here, just assuming that an invalid
    #       argument will cause dd to bail.
    decho "creating overlay image (size=$overlay_size)"
    dd if=/dev/null of=/overlay bs=1 count=0 seek=$overlay_size 2> /dev/null
    decho "losetup for overlay"
    OVERLAY_LOOPDEV=$( losetup -f )
    decho "device: $OVERLAY_LOOPDEV"
    losetup $OVERLAY_LOOPDEV /overlay

    # set up the snapshot
    #
    # NOTE: start_sector num_sectors target_type target_args
    #
    # NOTE: manpage doesn't describe snapshot's args...
    decho "setting up snapshot device (root-rw)"
    echo 0 `blockdev --getsz $BASE_LOOPDEV` snapshot $BASE_LOOPDEV $OVERLAY_LOOPDEV p 8 | dmsetup create root-rw
    decho "done"

    # set up new /dev/root symlink
    ln -fs /dev/mapper/root-rw /dev/root

    # mount the final rootfs
    decho "mounting final rootfs at /sysroot"
    mount /dev/root /sysroot

    # populate sysroot with config files
    #
    # NOTE: We used to create symlinks unless we were loading the rootfs.img
    #       into RAM, but that leads to problems with some applications that
    #       expect a file to be a normal file (e.g., /etc/sudoers) and was also
    #       causing all kinds of regressions (e.g., What if the file exists
    #       already in rootfs?  What if the config file you want to cp into
    #       rootfs needs to actually be a symlink?).  Additionally, the
    #       conditional code was getting a bit messy.  So, regardless, we now
    #       always recursively copy the files.
    #
    # NOTE: This would be much easier via rsync, but I didn't want to require
    #       adding rsync (and its required libs) to the initramfs.  Here's a
    #       list of the gotchas we have to address when overlaying the contents
    #       of the rootfs with the contents of conf:
    #
    #       1. Replacing a dir in rootfs w/ a symlink in conf.  If you don't
    #          handle this case specially, you end up with a symlink getting
    #          copied into the existing rootfs dir instead of replacing it.
    #          Problem can be avoided by removing the target dir in rootfs
    #          prior to doing a recursive copy.
    if [ -d /tmproot/conf ]; then
        echo -n "installing files from conf dir..."
        pushd /tmproot/conf >/dev/null
        find . -type l -exec mv /sysroot/{} /sysroot/{}.ruckusrd 2>/dev/null \;
        cp -dpR . /sysroot/
        popd >/dev/null
        echo " done"
    fi

    # update ld
    #
    # NOTE: we'll need to do this if the config area had any shared libs,
    #       otherwise our system could be unstable once booted.
    #
    # NOTE: we do this chrooted, so we only need to copy chroot into the
    #       initramfs.
    #
    # NOTE: while we do care if this fails, it really shouldn't make the
    #       system unbootable, so we'll ignore failure.
    #
    # NOTE: instead of hardcoding the path to ldconfig (which would be assuming
    #       too much about the system we're trying to boot, regardless of path
    #       standards), we setup an env with PATH set super-inclusively then let
    #       bash use PATH to find ldconfig inside the chrooted system.
    #
    # FIXME: this really only NEEDS to be done if we have a conf dir..., and
    #        there's a conditional for that right above.
    #
    decho "updating ld"
    CHROOTPATH=/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin
    chroot /sysroot /usr/bin/env -i PATH=$CHROOTPATH /bin/bash -c ldconfig \
        || echo -n

    # ensure the /dev/root symlink exists on the target system once udev is done
    # doing its thing
    #
    # FIXME: what if /dev on the real rootfs already has a /dev/root symlink
    #        (e.g., from the last time we booted)?  i want to let udev do
    #        it's thing... but if an old /dev/root exists and points to the
    #        wrong device, won't boot...  i can't guarantee that the
    #        /dev/root we created has been removed by the host system's init
    #        scripts on shutdown.
    #
    # FIXME: why were we doing this?  is there anything post initramfs that
    #        REQUIRES a /dev/root symlink?
    #
    decho "adding squashfs /dev/root tweak to rc.local"
    cat <<EOF >> /sysroot/etc/rc.local

if [ ! -f /dev/root ]; then
    ln -fs `readlink /dev/root` /dev/root 2>/dev/null
fi
EOF

fi


# do extra squashfs magic common to both old device-mapper and new overlayfs
# implementations
if [ -n "$sqsh_layers" ] || [ -f $SQUASHED ]; then
    decho "doing common squashfs finalization"

    # copy over module options
    #
    # NOTE: we really want to do this. without it there's no way to update
    #       modeprobe.conf before modules get loaded... can't exactly edit
    #       modprobe.conf and reboot, as our changes get lost.
    #
    # NOTE: but we don't want this if sqsh_layers w/out ram_overlay
    #
    if [ -z "$ram_layer" ] || [ -f $SQUASHED ]; then
        [ -f /etc/modprobe.conf ] && cat /etc/modprobe.conf >> /sysroot/etc/modprobe.conf
    fi

    # append a timestamp to system hostname if configured
    #
    # FIXME: this isn't very distro-agnostic, is it?
    #
    if [ -n "$hoststamp" ]; then
        stamp=`date +%s`
        decho "appending timestamp to hostname: $stamp"
        [ -f /sysroot/etc/sysconfig/network ] || break
        . /sysroot/etc/sysconfig/network
        [ -n "$HOSTNAME" ] || break
        for x in /etc/sysconfig/network /etc/hosts; do
            sed -i "s|\($HOSTNAME\)|\1-$stamp|" /sysroot/$x
        done
    fi

    # get ready to fix mtab
    #
    # NOTE: We can't just forge /etc/mtab at this point, because some systems
    #       sysinit scripts purge old cruft out of that file on the assumption
    #       that the initrd has ONLY mounted /.  So instead, we'll append a
    #       scriptlet that does the forging into rc.local.
    #
    # FIXME: This assumes a SysV-Init style system in /etc, which is a safe
    #        assumption considering all the other udev assumptions in
    #        here... but we'll want to address this at some point so we can
    #        work w/ systemd.
    #
    # NOTE: We always have the rc.local appendage, but the content changes
    #       depending on other params (e.g., squashdev, to_ram).
    #
    cp /sysroot/etc/rc.local{,.ruckusrdbak}
    cat <<EOF >> /sysroot/etc/rc.local
# --- begin ruckusrd appendage ---
echo rootfs / overlay $overlayflags 0 0 >> /etc/mtab
EOF

    # move /squashdev into /sysroot
    if [ -h /dev/squashdev ]; then
        decho "moving /squashdev to /sysroot/mnt/"
        mkdir -p /sysroot/mnt/squashdev
	mount --move /squashdev /sysroot/mnt/squashdev
	cat <<EOF >> /sysroot/etc/rc.local
echo /dev/squashdev /mnt/squashdev auto ro 0 0 >> /etc/mtab
EOF
    fi

    # move /sqsh_layerdev into /sysroot
    if [ -h /dev/sqsh_layerdev ]; then
        decho "moving /sqsh_layerdev to /sysroot/mnt/"
	mkdir -p /sysroot/mnt/sqsh_layerdev
        mount --move /sqsh_layerdev /sysroot/mnt/sqsh_layerdev
	cat <<EOF >> /sysroot/etc/rc.local
echo /dev/sqsh_layerdev /mnt/sqsh_layerdev auto ro 0 0 >> /etc/mtab
EOF
    fi

    # move individual layer mounts into /sysroot
    for x in $sqsh_layers_ws; do
        decho "moving /sqsh_layer-$x to /sysroot/mnt/"
        mkdir -p /sysroot/mnt/sqsh_layer-$x
        mount --move /sqsh_layer-$x /sysroot/mnt/sqsh_layer-$x
        cat <<EOF >> /sysroot/etc/rc.local
echo /dev/sqsh_layer-$x /mnt/sqsh_layer-$x auto ro 0 0 >> /etc/mtab
EOF
    done

    # move ram layer if needed
    if [ -n "$ram_layer" ]; then
        decho "moving /upper to /sysroot/mnt/"
        mkdir -p /sysroot/mnt/upper
        mount --move /upper /sysroot/mnt/upper
        cat <<EOF >> /sysroot/etc/rc.local
echo ram_layer /mnt/upper auto rw 0 0 >> /etc/mtab
EOF
    fi

    # Move the old sysroot into the new one, if needed.
    #
    # NOTE: root-true is left mounted unless to_ram was specified, in which
    #       case it is unmounted but the mountpoint is configured in /etc/fstab
    #       for easy re-mounting.
    #
    mkdir -p /sysroot/mnt/root-true
    if [ -z "$to_ram" ]; then
        decho "moving /tmproot to /sysroot/mnt/root-true"
	mount --move /tmproot /sysroot/mnt/root-true
	cat <<EOF >> /sysroot/etc/rc.local
echo /dev/root-true /mnt/root-true auto $root_true_rw 0 0 >> /etc/mtab
EOF
    else
        # setup easy mounting of /dev/root-true
        #
        # NOTE: we let the fstab injection fail to allow users to put new
        #       copies of fstab in the conf dir... which might overwrite
        #       /sysroot/etc/fstab with a symlink that's broken until we hand
        #       off control via switch_root.
        #
        echo "" >> /sysroot/etc/fstab || echo -n
        echo "/dev/root-true /mnt/root-true auto noauto,$root_true_rw 0 0" >> /sysroot/etc/fstab || echo -n

        # unmount it (so we can eject removable media)
        decho "unmounting /tmproot"
        umount /tmproot
    fi

    # add some debug output
    if [ "$quiet" != "1" ]; then
    cat <<EOF >> /sysroot/etc/rc.local
echo ---------------
df -h
echo ---------------
mount
echo ---------------
EOF
    fi

    # make sure rc.local doesn't grow into a giant mess
    #
    # NOTE: We made a copy of rc.local before we started appending to it.  This
    #       makes rc.local restore itself to its previous state once it's done
    #       executing our extra lines.
    #
    cat <<EOF >> /sysroot/etc/rc.local
cp /etc/rc.local{.ruckusrdbak,}
EOF

    # fix unmount chicken-and-the-egg problem
    #
    # NOTE: If not to_ram, the device(s) required to assemble the rootfs end up
    #       getting moved to mountpoints on top of the rootfs in the final
    #       system.  This leaves us with a can't unmount /mnt/squashdev w/out
    #       unmounting / first dilemma leading to potential errors and
    #       time-outs during shutdown.  The easy fix is to lazy-unmount the
    #       troublesome devices.  The messy part is how to do it w/out making
    #       assumptions about the system being booted.  We have to register
    #       some sort of script to execute at shutdown, after mostly everything
    #       has finished, but before the system tries to unmount its rootfs.
    #
    # FIXME: figure out how to make this not depend on SysV-Init style scripts,
    #        and the naming/ordering of the host systems shutdown/halt scripts.
    #
    if [ -z "$to_ram" ]; then
        cat <<EOF > /sysroot/etc/init.d/ruckusrd_umount
#!/bin/sh

# quietly umount rootfs dependencies that we left mounted on top of rootfs, so
# that we can umount / eventually.
umount -l /mnt/root-true 2>/dev/null
umount -l /mnt/squashdev 2>/dev/null
umount -l /mnt/sqsh_layerdev 2>/dev/null
EOF
        for x in $sqsh_layers_ws; do
            cat <<EOF >> /sysroot/etc/init.d/ruckusrd_umount
umount -l /mnt/sqsh_layer-$x 2>/dev/null
EOF
        done

        chmod +x /sysroot/etc/init.d/ruckusrd_umount
        ln -fs ../init.d/ruckusrd_umount /sysroot/etc/rc0.d/S00ruckusrd_halt
        ln -fs ../init.d/ruckusrd_umount /sysroot/etc/rc6.d/S00ruckusrd_reboot
    fi

    # and finally, remount /sysroot read-only because most/all systems expect /
    # to be mounted ro prior to their init systems taking over.
    mount -o remount,ro /sysroot
fi


# remount final root dev rw if requested
[ -n "$root_rw" ] && mount -o remount,rw /sysroot

if [ -n "$maint" ]; then
    echo "Dropping to a maintenance shell, as requested. Good luck!"
    echo
    bash
fi

# NOTE: Inside initramfs, prior to switch_root, if $init is a symlink w/
#       absolute path, it will be broken...
init_check=/sysroot$init
if [ -L $init_check ]; then
    init_check=/sysroot$(readlink $init_check)
fi
if [ ! -x $init_check ]; then
    echo "---------------------------------------------------------"
    echo "WARNING: Requested $init binary does not exist on rootfs."
    echo "---------------------------------------------------------"
    echo
    echo "Dropping to a shell. Good luck!"
    echo
    bash
fi

# Leave initramfs and transition to rootfs
#
kill `pidof udevd`

decho "switching to real rootfs..."
go="exec switch_root /sysroot $init $initargs"
decho $go
eval $go


echo "---------------------------------"
echo "WARNING: Error switching to real rootfs!"
echo "---------------------------------"
echo
echo "Dropping to a shell. Good luck!"
echo
bash
