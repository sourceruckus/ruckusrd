#!/bin/bash
#
# RuckusRD - a super awesome, yet simple, mkinitrd replacement
#
# Copyright 2012-2020 Michael D Labriola <michael.d.labriola@gmail.com>
#
# Licensed under the GPLv3. See the file COPYING for details. 
#
# This script is a utility for installing a built kernel onto a remote machine
# via ssh/rsync.  First run `kernel_builder`, then run this.

export SRP_ROOT=$PWD/FOO

target_host=$1
if [ -z "$target_host" ]; then
    echo "need to specify target host"
    exit -1
fi

# figure out VERSION, which might be a stable .y version w/ a symlink
for x in $SRP_ROOT/lib/modules/*; do
    if [ -h $x ]; then
        VERSION=$(readlink $x)
        VERSION_NAME=$(basename $x)
        break
    else
        VERSION=$(basename $x)
    fi
done

[ -n "$VERSION" ] || exit 1

echo VERSION: $VERSION
echo VERSION_NAME: $VERSION_NAME
echo target_host: $target_host

# we do this in a single line to reduce the number of ssh authentications
# necessary
#
# FIXME: why the heck didn't i just do rysnc --delete?  You can't really
#        accomplish all this w/ rsync --delete because our new...  well, what
#        about the case where we're accidentally re-installing the same thing.
#        in that case, 5.8.y->5.8.9, we'll remove 5.8.9 and then needlessly
#        re-install it.  but we really do need to do symlink checking and
#        removing prior to the rsync, otherwise we'll loose track of the
#        symlink.  making the stable symlink magic work all the time, while not
#        needlessly re-installing, would be a bit non-trivial...
#
#        1. record where stable symlink points.
#
#        2. if new version != current stable, remove old stable tree.
#
#        3. rsync --delete new one (potentially overwriting/deleting if new ==
#        current), which includes the new stable symlink.
#
echo removing preexisting modules and headers on $target_host
go="rm -rf /lib/modules/$VERSION /usr/src/linux-headers-$VERSION"
if [ -n "$VERSION_NAME" ]; then
    # we're installing a stable symlink.  let's remove any pre-existing symlink
    # AND what it currently points at.  we're going to be removing the boot
    # files anyways, so the leftover modules and headers dirs are just leftover
    # junk anyways.
    #
    # FIXME: corner case: install 5.7.0, then install 5.7.y.  that will
    #        overwrite the 5.7.0 modules, and then upgrading to the next 5.7.y
    #        will remove 5.7.0's modules, rendering it broken.
    #
    #        should we check for existence of matching /boot files before
    #        removing symlink target modules?  [ -f /boot/vmlinuz-$VERSION ] ??
    #
    #        i think that's getting too convoluted... just don't do that.
    #
    go+="; [ -h /lib/modules/$VERSION_NAME ] && rm -rf /lib/modules/\$(readlink /lib/modules/$VERSION_NAME) /lib/modules/$VERSION_NAME"
    go+="; [ -h /usr/src/linux-headers-$VERSION_NAME ] && rm -rf /usr/src/\$(readlink /usr/src/linux-headers-$VERSION_NAME) /usr/src/linux-headers-$VERSION_NAME"
fi
echo $go
ssh root@$target_host "$go"

echo installing files on $target_host
# FIXME: why -u? i just deleted everything a few lines ago...
#
# NOTE: We use -rltD here instead of -a because we actually don't want to keep
#       perms (-p), group (-g), and owner (-o)... because who wants there
#       kernel files to be owned by anyone other than root.
#
# FIXME: why --keep-dirlinks?  i must have gotten bitten by not using it... but
#        i don't actually remember the scenario.  /boot was a symlink maybe?
#        or /lib/modules?
#
rsync -vzurltD --keep-dirlinks $SRP_ROOT/ root@$target_host:/ || exit 2
