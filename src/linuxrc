#!/bin/bash
#
# Copyright 2012 Michael D Labriola <michael.d.labriola@gmail.com>
#
# Licensed under the GPLv3. See the file COPYING for details. 
#
# This initramfs /init script is a derivative of the one embedded in mayflower
# (flexible mkinitrd replacement used originally by fedora's livecd-creator,
# David Zeuthen <davidz@redhat.com>).
#
# It's been largely rewritten to be used as the initramfs /init script for a
# mkinitrd replacement that can be used on embedded systems, flash drives, live
# CDs, and normal desktop Linux systems.  See the file README for details.
#
# NOTE: At the moment, and this might change, we're not loading KMS video
#       drivers in here.  I was planning on doing just that, but I couldn't
#       quite get things working the way I wanted.
#
#       For example, using nouveau on one of our old dual-Xeons, even if the
#       very fist line of the script is 'modprobe nouveau', you don't get
#       penguin logos.  However, if nouveau is actually built into the kernel,
#       you get penguins a split second after booting starts, but you also get a
#       big white box that obscures some of the output.  So the best way to
#       ensure you get the penguin logos appears to still be to set
#       vga=something to initialize the vga framebuffer for a few seconds before
#       the KMS video driver gets loaded.  And If we do that and then load the
#       KMS driver in the initrd, you get two modesets within a 1-2 second
#       window... which just looks strange.
#
#       If we ever decide to play with plymouth or some other nice splash screen
#       utility, we might want to revisit this and just ditch the penguin logos
#       (although I kinda like being able to see right off the bat how many CPUs
#       have been detected).


decho()
{
    if [ "$quiet" != "1" ]; then
        echo "$*"
    fi
}


do_raid_and_lvm()
{
    # wait for at least one harddisk to be handled by udev
    #
    # NOTE: this is needed because this method might be called before we can
    #       guarantee that udev has finished loading modules.
    x=$1
    msg="waiting up to $x seconds for at least one hdd to appear..."
    while [ ! -e /dev/sda -a "$x" != "0" ]; do
        if [ -n "$msg" ]; then
            echo -n $msg
            msg=""
        else
            echo -n "."
        fi
        x=$(($x-1))
        sleep 1
    done
    [ -z "$msg" ] && echo " done"

    # if we were asked to wait, wait another second
    #
    # NOTE: this should make it almost impossible to fail to detect devices due
    #       to concurrency problems.  the only way for it to happen now is if
    #       /dev/sda *JUST* got created when the previous waitloop started (so
    #       we don't wait at all), but we get to this 2nd conditional before
    #       /dev/sdb has been created.
    [ "$1" != "0" ] && sleep 1

    # autogen mdadm.conf
    echo 'DEVICE /dev/sd*[0-9]' > /etc/mdadm.conf
    mdadm --examine --scan | sed 's|/dev/.tmp.|/dev/|' >> /etc/mdadm.conf
    [ "$quiet" != "1" ] && cat /etc/mdadm.conf

    grep ARRAY /etc/mdadm.conf >/dev/null && raid=1 || raid=0
    if [ "$raid" != "0" ]; then
        echo "initializing RAID devices..."
        go="mdadm --assemble --scan"
        [ "$quiet" != "1" ] && go="$go -v"
        decho $go
        eval $go
    fi

    echo "initializing LVM..."

    go="lvm vgscan --mknodes"
    [ "$quiet" != "1" ] && go="$go -v"
    decho $go
    eval $go

    go="lvm vgchange -a y"
    [ "$quiet" != "1" ] && go="$go -v"
    decho $go
    eval $go
}


emergency_shell()
{
    echo "Bug in initramfs /init detected. Dropping to a shell. Good luck!"
    echo
    bash
}


trap "emergency_shell" 0 2

# exit immediately if a command fails
set -e

PATH=/sbin:/bin

exec < /dev/console > /dev/console 2>&1

# mount tmpfs for /dev
mount -n -t tmpfs -o mode=0755 udev /dev

# create initial device nodes
mknod /dev/console c 5 1
mknod /dev/null c 1 3
mknod /dev/kmsg c 1 11
mkdir /dev/pts
mkdir -m 1777 /dev/shm
ln -s /proc/self/fd /dev/fd
ln -s fd/0 /dev/stdin
ln -s fd/1 /dev/stdout
ln -s fd/2 /dev/stderr

# mount virtual filesystems
mount -n -t proc proc /proc
mount -n -t sysfs sysfs /sys

# setup hotplug
echo "" > /proc/sys/kernel/hotplug

SQUASHED="/sysroot/squashfs.img"

# Declare all variables here.. mostly for housekeeping
init="/sbin/init"
root=""
root_rw=""
rootflags=""
rootfstype="auto"
to_ram=""
maint=""
hoststamp=""
quiet=0
overlay_size="512M"
dmroot=0

# Parse kernel commandline options
#
# NOTE: By default, when this script hands off control the the underlying
#       root filesystem's init process, the rootfs will be mounted ro.  This
#       behavior can be overriden by passing 'rw' on the kernel command
#       line.
#
# NOTE: rootfstype, rootflags are only applied when mounting the specified root
#       device.  in other words, they are not used when mounting the derivitive
#       devices created when we load rootfs into RAM.
for o in `cat /proc/cmdline` ; do
    case $o in 
    init=*)
        init=${o#init=}
        ;;
    quiet)
        quiet=1
        ;;
    to_ram)
        to_ram=1
	;;
    maint)
	maint=1
	;;
    rw)
        root_rw=1
	;;
    hoststamp)
        hoststamp=1
        ;;
    blacklist=*)
        blacklist=${o#blacklist=}
        echo "blacklist $blacklist" >> /etc/modprobe.conf
        ;;
    root=*)
        root=${o#root=}
        ;;
    rootflags=*)
        rootflags=${o#rootflags=}
        ;;
    rootfstype=*)
        rootfstype=${o#rootfstype=}
        ;;
    overlay_size=*)
        overlay_size=${o#overlay_size=}
        ;;
    *)
        # NOTE: putting "loop.max_loop=16" in cmdline would cause "options loop
        #       max_loop=16" to get written in modprobe.conf...
        m=$(echo $o |cut -s -d . -f 1)
        opt=$(echo $o |cut -s -d . -f 2-)
        if [ -z "$m" -o -z "$opt" ]; then
          continue
        fi
        p=$(echo $opt |cut -s -d = -f 1)
        v=$(echo $opt |cut -s -d = -f 2-)
        if [ -z "$p" -o -z "$v" ]; then
          continue
        fi
        echo "options $m $p=$v" >> /etc/modprobe.conf
        ;;
    esac
done

decho "kernel commandline: `cat /proc/cmdline`"
decho "init=$init"
decho "root=$root"
decho "to_ram=$to_ram"
decho "rootflags=$rootflags"
decho "rootfstype=$rootfstype"
decho "overlay_size=$overlay_size"

echo -n "determining what to mount... "

# NOTE: we try to depend on the hotplug implementation as little as possible in
#        here (i.e., we're leaving the door open for mdev as much as possible).

# generate udev rules to generate /dev/root symlink
if [ -z $root ] ; then
    root=/dev/something
else
    # NOTE: we're assuming SCSI device nodes here, now that SATA, PATA, USB, and
    #       SCSI should all be using them.
    case $root in
        CDLABEL=*)
            CDLABEL=${root#CDLABEL=}
            echo "KERNEL==\"sr[0-9]\", PROGRAM=\"/lib/udev/vol_id -l %N\", RESULT==\"$CDLABEL\", SYMLINK+=\"root\"" >> /etc/udev/rules.d/00-cdlabel.rules
            echo "KERNEL==\"scd[0-9]\", PROGRAM=\"/lib/udev/vol_id -l %N\", RESULT==\"$CDLABEL\", SYMLINK+=\"root\"" >> /etc/udev/rules.d/00-cdlabel.rules
            decho "Added udev rule for CDLABEL=='$CDLABEL'"
            thingtomount=/dev/root
            ;;
        LABEL=*)
            LABEL=${root#LABEL=}
            echo "SUBSYSTEM==\"block\", PROGRAM=\"/lib/udev/vol_id -l %N\", RESULT==\"$LABEL\", SYMLINK+=\"root\"" > /etc/udev/rules.d/00-label.rules
            decho "Added udev rule for LABEL=='$LABEL'"
            thingtomount=/dev/root
            dmroot=1
            ;;
        UUID=*)
            UUID=${root#UUID=}
            echo "SUBSYSTEM==\"block\", PROGRAM=\"/lib/udev/vol_id -u %N\", RESULT==\"$UUID\", SYMLINK+=\"root\"" > /etc/udev/rules.d/01-uuid.rules
            decho "Added udev rule for UUID=='$UUID'"
            thingtomount=/dev/root
            dmroot=1
            ;;
        /dev/md*|/dev/V*|/dev/mapper/*)
            ln -s $root /dev/root
            thingtomount=$root
            dmroot=1
            ;;
        /dev/*)
            ln -s $root /dev/root
            thingtomount=$root
            ;;
        *)
            thingtomount=$root
            ;;
    esac
fi

echo $thingtomount

echo "udev_log=\"error\"" >> /etc/udev/udev.conf

# rules for loading modules
#
echo -n "ACTION==\"add\", SUBSYSTEM==\"?*\", ENV{MODALIAS}==\"?*\", RUN+=\"/sbin/modprobe $" >> /etc/udev/rules.d/10-modprobe.rules
echo "env{MODALIAS}\"" >> /etc/udev/rules.d/10-modprobe.rules

decho "starting udevd"
/sbin/udevd --daemon
if [ -x /sbin/udevadm ]; then
    /sbin/udevadm trigger
else
    # using an old version of udev, FC5-ish
    /sbin/udevstart
fi

# initialize LVM if needed now
#
# NOTE: We're asking the init method to wait up to 10 seconds for udev to load
#       modules for drive controllers before we kick off initialization of LVM.
#       Withouth the sleep, vgscan might run prior to the kernel noticing the
#       existance of the harddrive that contains the volgroup...
if [ "$dmroot" != "0" ]; then
    do_raid_and_lvm 10
fi

# wait for root symlink
#
# NOTE: this loop waits up to 30 seconds for /dev/root symlink to get created.
#       if it takes longer than that, something is wrong, but maybe the user can
#       fix it.
x=30
msg="waiting up to $x seconds for /dev/root symlink..."
while [ ! -e /dev/root -a "$x" != "0" ]; do
    if [ -n "$msg" ]; then
        echo -n $msg
        msg=""
    else
        echo -n "."
    fi
    x=$(($x-1))
    sleep 1
done
root_true=`readlink /dev/root`

# NOTE: At this point, either /dev/root exists OR our waitloop timed out.  We'll
#       give the user a chance to manually create the /dev/root symlink.
if [ -b /dev/root ] ; then
    [ -z "$msg" ] && echo " done"
    decho "/dev/root symlink exists ($root_true)"
else
    echo
    echo
    echo "--------------------------------------"
    echo "WARNING: Cannot find root file system!"
    echo "--------------------------------------"
    echo
    echo "Create symlink /dev/root and then exit this shell to continue"
    echo "the boot sequence."
    echo
    bash
fi

mountoptions=" -o ro"
if [ -n "$rootflags" ]; then
    mountoptions+=",$rootflags"
fi

go="mount -n -t $rootfstype $mountoptions $thingtomount /sysroot"
decho $go
eval $go
RES=$?

if [ "$RES" != "0" ] ; then
    echo "---------------------------------"
    echo "WARNING: Cannot mount rootfs!"
    echo "---------------------------------"
    echo
    echo "Dropping to a shell. "
    echo "Mount rootfs at /sysroot and exit shell to continue. Good luck!"
    echo
    bash
fi

# only pass kernel command line if we're launching /sbin/init
if [ "$init" == "/sbin/init" ] ; then
    initargs=$(cat /proc/cmdline)
else
    initargs=""
fi

# initialize device mapper and LVM
#
# NOTE: This was already done at the very beginning if root was specified as
#       /dev/mapper/*.  We're going to do it now if it hasn't already been done,
#       just so we can assume from here on out that the device mapper and LVM
#       have been initialized.
#
# NOTE: We tell the init method to not wait for devices at this point, assuming
#       that udev has had plenty of time to create device nodes.
if [ "$dmroot" != "1" ]; then
    do_raid_and_lvm 0
fi


# NOTE: if $SQUASHED exists, the system we're attempting to boot has been
#       set up with a squashfs read-only rootfs image to be used with a
#       writable overlay using some device mapper voodoo
#
# NOTE: additionally, $SQUASHED can be loaded into RAM to free up the
#       underlying root device (excellent for booting off removable media on
#       systems with enough RAM to handle such a thing.
if [ -f $SQUASHED ]; then
    decho "setting up squashfs device mapper voodoo"

    if [ -n "$to_ram" ]; then
	echo -n "Copying compressed rootfs image to RAM... "
	dd if=$SQUASHED of=/squashed.img bs=512 2> /dev/null
	echo "done"
	SQUASHED="/squashed.img"
    fi

    SQUASHED_LOOPDEV=$( losetup -f )
    losetup $SQUASHED_LOOPDEV $SQUASHED
    mkdir -p /squashfs
    mount -n -t squashfs -o ro $SQUASHED_LOOPDEV /squashfs

    BASE_LOOPDEV=$( losetup -f )
    losetup $BASE_LOOPDEV /squashfs/rootfs.img

    umount -l /squashfs

    # create a sparse file for the overlay
    #
    # NOTE: this uses our overlay_size variable, which can be set on the command
    #       line. we do no syntax checking here, just assuming that an invalid
    #       argument will cause dd to bail.
    decho "creating overlay image (size=$overlay_size)"
    dd if=/dev/null of=/overlay bs=1 count=0 seek=$overlay_size 2> /dev/null
    OVERLAY_LOOPDEV=$( losetup -f )
    losetup $OVERLAY_LOOPDEV /overlay

    # set up the snapshot
    #
    # NOTE: start_sector num_sectors target_type target_args
    #
    # NOTE: manpage doesn't describe snapshot's args...
    echo 0 `blockdev --getsz $BASE_LOOPDEV` snapshot $BASE_LOOPDEV $OVERLAY_LOOPDEV p 8 | dmsetup create root-rw

    # set up new /dev/root symlink
    rm -f /dev/root
    ln -s /dev/mapper/root-rw /dev/root

    # if we didn't load squashfs.img into RAM, we need to move things around
    # so that the final system can still have access (if needed) to the
    # underlying device.  otherwise we end up with the new root mounted on
    # top of the old root, and users won't be able to access the old root at
    # all.
    #
    # NOTE: we always do this regardless of the to_ram variable so that we can
    #       always have access to the original root device to scarf config files
    #       from throughout this.  if to_ram is set, we will umount /tmproot
    #       before we're all done.
    mkdir /tmproot
    mount --move /sysroot /tmproot

    # mount the final rootfs
    mount /dev/root /sysroot

    # copy over module options
    #
    # NOTE: we really want to do this. without it there's no way to update
    #       modeprobe.conf before modules get loaded... can't exactly edit
    #       modprobe.conf and reboot, as our changes get lost.
    [ -f /etc/modprobe.conf ] && cat /etc/modprobe.conf >> /sysroot/etc/modprobe.conf

    # populate sysroot with config files
    #
    # NOTE: we create symlinks under normal operations, but if we've loaded the
    #       rootfs.img into RAM we should cp the files into the appropriate
    #       directories on root-rw
    #
    # NOTE: have to do this in 2 iterations.  1st, we make all parent
    #       directories that will be needed to house symlinks.  2nd, we create
    #       the symlinks/copies.
    #
    # NOTE: we've got bash set to exit immediately if a command fails, so we
    #       have to make sure wild-card expansions don't cause find to fail.
    #       more accurately, we're just going to ignore find failures
    #       altogether by echoing nothing in a || contidional.
    if [ -d /tmproot/conf ]; then
        pushd /tmproot/conf >/dev/null
        find * -type d -exec mkdir -p /sysroot/{} \; 2>/dev/null || echo -n
        if [ -z "$to_ram" ]; then
            find * -type f -exec ln -s /mnt/root-true/conf/{} /sysroot/{} \; || echo -n
        else
            find * -type f -exec cp {} /sysroot/{} \; || echo -n
        fi
        popd >/dev/null
    fi

    # create udev rules for /dev/root-* symlinks
    #
    # NOTE: these symlinks point to the corresponding loop devices we've created
    #       in here as well as the "true" root device
    rules=/sysroot/etc/udev/rules.d/50-ruckusrd.rules
    echo "KERNEL==\"${root_true#/dev/}\", SYMLINK+=\"root-true\"" >> $rules
    echo "KERNEL==\"${SQUASHED_LOOPDEV#/dev/}\" SYMLINK+=\"root-loop-squash\"" >> $rules
    echo "KERNEL==\"${BASE_LOOPDEV#/dev/}\" SYMLINK+=\"root-loop-rootfs\"" >> $rules
    echo "KERNEL==\"${OVERLAY_LOOPDEV#/dev/}\" SYMLINK+=\"root-loop-overlay\"" >> $rules

    # setup easy mounting of /dev/root-true
    mkdir -p /sysroot/mnt/root-true
    echo "" >> /sysroot/etc/fstab
    echo "/dev/root-true /mnt/root-true auto noauto,ro 0 0" >> /sysroot/etc/fstab

    # ensure the /dev/root symlink exists on the target system once udev is done
    # doing its thing
    cat <<EOF >> /sysroot/etc/rc.local

if [ ! -f /dev/root ]; then
    ln -s `readlink /dev/root` /dev/root 2>/dev/null
fi
EOF

    # append a timestamp to system hostname if configured
    #
    # FIXME: this isn't very distro-agnostic, is it?
    if [ -n "$hoststamp" ]; then
        stamp=`date +%s`
        [ -f /sysroot/etc/sysconfig/network ] || break
        . /sysroot/etc/sysconfig/network
        [ -n "$HOSTNAME" ] || break
        for x in /etc/sysconfig/network /etc/hosts; do
            sed -i "s|\($HOSTNAME\)|\1-$stamp|" /sysroot/$x
        done
    fi

    # Move the old sysroot into the new one, if needed.
    #
    # NOTE: We can't just forge /etc/mtab at this point, because some systems
    #       sysinit scripts purge old cruft out of that file on the assumption
    #       that the initrd has ONLY mounted /.  So instead, we'll append a
    #       scriptlet that does the forging into rc.local.
    #
    # FIXME: this works, but the resulting sytem hangs for a few seconds
    #        during reboot trying over and over again to umount root-true...
    #
    # FIXME: there might not be a good fix for this problem here w/out having a
    #        knowledge of the system we're trying to boot (i.e., we can't go
    #        sedding specific init scripts because we want to be
    #        distro-agnostic)
    if [ -z "$to_ram" ]; then
	mount --move /tmproot /sysroot/mnt/root-true
	cat <<EOF >> /sysroot/etc/rc.local

echo /dev/root-true /mnt/root-true auto ro 0 0 >> /etc/mtab
EOF
    else
        umount /tmproot        
    fi

    mount -o ro,remount /sysroot
fi

# remount final root dev rw if requested
[ -n "$root_rw" ] && mount -o rw,remount /sysroot

if [ -n "$maint" ]; then
    echo "Dropping to a maintenance shell, as requested. Good luck!"
    echo
    bash
fi
    
if [ ! -x /sysroot$init ] ; then
    echo "---------------------------------------------------------"
    echo "WARNING: Requested $init binary does not exist on rootfs."
    echo "---------------------------------------------------------"
    echo
    echo "Dropping to a shell. Good luck!"
    echo
    bash
fi

# Leave initramfs and transition to rootfs
#
kill `pidof udevd`

decho "switching to real rootfs..."
go="exec switch_root /sysroot $init $initargs"
decho $go
eval $go


echo "---------------------------------"
echo "WARNING: Error switching to real rootfs!"
echo "---------------------------------"
echo
echo "Dropping to a shell. Good luck!"
echo
bash
