#!/bin/ash
#
# Copyright 2012-2024 Michael D Labriola <veggiemike@sourceruckus.org>
#
# Licensed under the GPLv3. See the file COPYING for details. 
#
# This initramfs /init script is a derivative of the one embedded in mayflower
# (flexible mkinitrd replacement used originally by fedora's livecd-creator,
# David Zeuthen <davidz@redhat.com>).
#
# It's been largely rewritten (multiple times now) to be used as the initramfs
# /init script for a mkinitrd replacement that can be used on embedded systems,
# flash drives, live CDs, and normal desktop Linux systems.  See the file
# README for details.
#
# ---- BUSYBOX COMPAT NOTE ----
# So far, this script uses the following non-basic features that I should
# double-check for busybox applet compatibility moving forward:
#
# - sed -i (yes!)
# - bash ${param#word} and ${param//pattern/string} expansions (yes and yes!)
# - bash trap and set -e (yes!)
# - bash $() command subst (yes!)
# - bash {} globbing (e.g., cp foo{,bak}) (NOPE)
# - bash var+= (NOPE)


# prepend $* with "ruckusrd:" label, while potentially reordering $* so that
# command line args to echo (e.g., -n) are still at the front (so echo will
# actually consume them).
#
# NOTE: If -n has been specified, the "ruckusrd:" label is NOT preppended
#       (because -n is used for continually updating the line and we don't want
#       multiple "ruckusrd:" labels).  In this case, it's up to the user to add
#       it.
#
# FIXME: This does eat leading space off of the output message, even if
#        quoted... not sure I like that... but I don't think I can fix it...
#
__preppend_and_reorder()
{
    flags=
    preppend="ruckusrd: "
    # iterate through $* until $1 does NOT start with a flag
    while [ -n "$1" ]; do
        case "$1" in
            -*n*)
                # don't preppend in this case, as we're doing some sort of
                # updating line thingy (e.g., . . . . accross the screen until
                # finished).
                preppend=
                ;;
        esac
        case "$1" in
            -*)
                [ -n "$flags" ] && flags="$flags "
                flags="$flags$1"
                shift
                ;;
            *)
                # as soon as we encounter an item that isn't potentially a
                # command line option to echo, we stop parsing things.
                break
                ;;
        esac
    done
    echo "$flags $preppend$*"
}


decho()
{
    if [ -z "$quiet" ] || [ -n "$verbose" ]; then
        echo $(__preppend_and_reorder $*)
    fi
}

decho2()
{
    if [ -n "$verbose" ]; then
        echo $(__preppend_and_reorder $*)
    fi
}


# Wait up to $1 seconds for any of the specified device nodes to exist.  If
# timeout occurs, something is wrong, but maybe the user can fix it, so we drop
# to an emergency shell.
#
# Example: wait_for_dev 10 fwdev LABEL=FIRMWARE
#
# Example: wait_for_dev 10 "at least ond hdd" /dev/sda /dev/nvme0n1 /dev/xvda
#
# Example: wait_for_dev 30 "/dev/root symlink" /dev/root
#
# NOTE: Adds device-mapper device name responsible for the required device to
#       global $dmneeded prior to returning.
#
wait_for_dev()
{
    seconds=$1
    txt=$2
    shift 2
    devices=$*

    msg="waiting up to $seconds seconds for $txt to appear..."
    found=
    while [ $seconds -gt 0 ]; do
        if [ -n "$msg" ]; then
            decho -n ruckusrd: $msg
            msg=""
        else
            decho -n "."
        fi
        # just in case we need to activate LVM on a freshly plugged device
        # (e.g., USB that was a bit slow to register)
        vgchange -a y --quiet --quiet
        # check for each device
        for dev in $devices; do
            decho2 "checking dev=$dev..."
            # try to resolve LABEL= and the like
            #
            # NOTE: This looks wonky because finds prints either a resolved
            #       block device name or nothing if not found... but if passed
            #       a /dev/whatever it doesn't look it just prints it back
            #       out... so findfs /dev/blargynotreal will print
            #       /dev/blargynotreal and we have to verify it exists still.
            #
            dev=$(findfs $dev || echo -n)
            [ -n "$dev" ] || continue
            if [ -e $dev ]; then
                found=$dev
                # break out of both loops, we're done done
                break 2
            fi
        done
        seconds=$(($seconds-1))
        decho2 "waiting for $seconds more seconds"
        sleep 1
    done

    # NOTE: At this point, either a device we were waiting for exists OR our
    #       waitloop timed out.  If we timed out, qe'll give the user a chance
    #       to manually fix things.
    #
    # FIXME: original fwdev wait code didn't treat failure as fatal... this is
    #        probably better, but think it over.
    #
    if [ -n "$found" ]; then
        [ -z "$msg" ] && decho -en ". $found found\n"
        decho2 "$found exists (waited on: $devices)"
    else
        echo
        echo
        echo "--------------------------------------"
        echo "WARNING: Timed out waiting for $devices!"
        echo "--------------------------------------"
        echo
        echo "Create devices (or symlinks) manually and then exit this shell to continue"
        echo "the boot sequence."
        echo
        control_shell
    fi

    dmneeded="$dmneeded $(dmsetup info -c --noheadings -o name $found 2>/dev/null || echo)"
}


emergency_shell()
{
    echo "Bug in initramfs /init detected. Dropping to a shell. Good luck!"
    echo
    control_shell
}


control_shell()
{
    echo "uptime: $(cat /proc/uptime | cut -d' ' -f1)"
    echo
    setsid cttyhack env LESS=-cMR bash
}


modprobe()
{
    grep -q $1.ko /lib/modules/$(uname -r)/modules.builtin || /sbin/modprobe $*
}


autoload_fs_module()
{
    TYPE=
    # NOTE: Normal blkid can be given LABEL=whatever here and do the right
    #       thing.  The busybox version doesn't like it, though.  But busybox
    #       does provide findfs, which can do the lookup for us.
    eval $(blkid $(findfs $1) | sed 's|.*: ||')
    [ -n "$TYPE" ] && modprobe $TYPE
}


# This method creates udev rules such that we end up with a /dev/$1 symlink
# that points to the device specified by $2, which can be CDLABEL, LABEL, UUID,
# or an actual device name (e.g., /dev/sda1, /dev/md0, /dev/mapper/vg0_lv1).
#
# NOTE: This method modifies the following important global variables:
#
#       thingtomount: argument to be mounted for root filesys
#
generate_udev_rules()
{
    name=$1
    str=$2

    # FIXME: probably want to entirely rewrite these rules for eudev (upstream
    #        220).
    #
    case $str in
        # NOTE: While CDLABEL and LABEL could use the same udev rule, we use
        #       the different str to differentiate later on (e.g., for fsck).
        #
        CDLABEL=*)
            # NOTE: we're assuming SCSI device nodes here, now that SATA, PATA,
            #       USB, and SCSI should all be using them.
            #
            # FIXME: can we just use the cdrom.rule's ID_CDROM=1?  looks like
            #        no...
            #
            CDLABEL=${str#CDLABEL=}
            cat <<EOF >> etc/udev/rules.d/99-ruckusrd.rules
SUBSYSTEM=="block", KERNEL=="sr[0-9]*", ENV{ID_FS_LABEL_ENC}=="$CDLABEL", SYMLINK+="$name"
EOF
            decho2 "Added udev rule for CDLABEL=='$CDLABEL'"
            if [ "$name" = "root" ]; then
                thingtomount=/dev/root
            fi
            ;;
        LABEL=*)
            LABEL=${str#LABEL=}
            cat <<EOF >> etc/udev/rules.d/99-ruckusrd.rules
SUBSYSTEM=="block", KERNEL!="sr[0-9]", ENV{ID_FS_LABEL_ENC}=="$LABEL", SYMLINK+="$name"
EOF
            decho2 "Added udev rule for LABEL=='$LABEL'"
            if [ "$name" = "root" ]; then
                thingtomount=/dev/root
            fi
            ;;
        UUID=*)
            UUID=${str#UUID=}
            cat <<EOF >> etc/udev/rules.d/99-ruckusrd.rules
SUBSYSTEM=="block", ENV{ID_FS_UUID_ENC}=="$UUID", SYMLINK+="$name"
EOF
            decho2 "Added udev rule for UUID=='$UUID'"
            if [ "$name" = "root" ]; then
                thingtomount=/dev/root
            fi
            ;;
        ZFS=*)
            # NOTE: We don't use udev here.  Instead, we've got a block of ZFS
            #       initialization code down below that uses the ZFS and
            #       ZFS_POOL variables, set here.
            #
            ZFS=${str#ZFS=}
            ZFS_POOL=${ZFS%%/*}
            if [ "$name" = "root" ]; then
                thingtomount=$ZFS
                rootfstype=zfs
            elif [ "$name" = "sqsh_layerdev" ]; then
                thingtomount_sqsh=$ZFS
                sqshfstype=zfs
            fi
            ;;
        /dev/*)
            ln -fs $str /dev/$name
            if [ "$name" = "root" ]; then
                thingtomount=$str
            fi
            ;;
        *)
            if [ "$name" = "root" ]; then
                thingtomount=$str
            fi
            ;;
    esac
}


lookup_layer()
{
    name=$1.sqsh
    for path in $sqsh_layerdir; do
        if [ -e $path/$name ]; then
            echo $path/$name
            return
        fi
    done

    # just in case it's not found, echo something sane-ish looking so we don't
    # end up with wrong number of arguments later on.
    echo not-found-$name
}


# FIXME: maybe start_udev, start_md, start_lvm, and start_zfs should be
#        installed in /sbin so they can be executed easily by hand once logged
#        in?
#
#        well, lvm is just a single call to vgchange...  similarly, zfs is just
#        zpool import.  and it looks like md is being automatically configured
#        by the kernel.  So really just start_udev is non-trivial.
#
#        starting to think maybe that's silly...  plus, this func has nice
#        verbose/quiet support that would be lost (perhaps?) if we made it a
#        script in /sbin.
#
#        we could fix the verbose/quiet stuff and add start_dhcp, start_sshd as
#        well
#
start_udev()
{
    # prep udev hwdb
    go="/sbin/udevadm"
    [ -n "$verbose" ] && go="$go --debug"
    go="$go hwdb --update"
    decho2 $go
    eval $go

    decho2 "starting udevd"
    /sbin/udevd --daemon --resolve-names=never

    # tell udevd to start processing its queue
    #
    # NOTE: I used to just trigger and settle...  LFS does these 3 triggers and
    #       then conditionally settles.  Not 100% sure of the rationale, but
    #       I'll follow LFS on this one.
    #
    /sbin/udevadm trigger --action=add --type=subsystems
    /sbin/udevadm trigger --action=add --type=devices
    /sbin/udevadm trigger --action=change --type=devices
}


start_ruckusrd_system()
{
    # set hostname to something unique
    hostname ruckusrd-`date +%Y%m%d%H%M%S`

    # clean up some stuff we won't be needing
    #
    # FIXME: should we consider removing more?  We've only got 25% of total RAM
    #        for rootfs, and no easy way to monitor that...  we could remove
    #        /usr/src to free up 115M...  is anyone really going to be trying
    #        to compile kernel modules from in here?
    #
    #        sadly, that might actually be a use case for this shell...  fixing
    #        borked 3rd party but important kernel modules that are non-trivial
    #        to fix (e.g., NVIDIA, ZFS, DRBD)
    #
    rm -rf /kernel
    rmdir /sysroot

    # NOTE: Traditionally this would be done after switch_root via an rcS
    #       script, but we've already done all the rest of the stuff that
    #       script would normally handle (e.g., initial device nodes, virtual
    #       filesystem mounts)... and we're really not switching to another
    #       rootfs.  So we do it here.
    #
    start_udev
    sleep 1

    # attempt to mount efivars
    if [ -d /sys/firmware/efi ]; then
        decho "mounting efivars"
        mount efivarfs -t efivarfs /sys/firmware/efi/efivars || echo "WARNING: Failed to mount efivars. Cannot manage UEFI settings."
    else
        decho "system doesn't support EFI, not mounting efivars"
    fi

    # check for existence of serial devices and uncomment getty entries in
    # /etc/inittab accordingly
    [ -c /dev/ttyS0 ] && sed -i 's|^#ttyS0::|ttyS0::|' /etc/inittab
    [ -c /dev/hvc0 ] && sed -i 's|^#hvc0::|hvc0::|' /etc/inittab

    # hand off control to /sbin/init
    go="exec /sbin/init"
    decho2 $go
    eval $go
}


trap "emergency_shell" 0 2

# exit immediately if a command fails
set -e

PATH=/sbin:/bin

exec < /dev/console > /dev/console 2>&1

# before we start mounting anything, let's fix file ownership/perms on the
# entire initramfs.
#
# NOTE: This is needed because in order to be able to create initramfs as
#       non-root users, we cannot change ownership of the files it contains
#       while running ruckusrd.
#
chown -R root:root /
chgrp utmp /var/log/lastlog
chown -R ruckus:users /home/ruckus
chmod u+s /bin/busybox

# mount devtmpfs for /dev
mount -n -t devtmpfs -o mode=0755 devtmpfs /dev || \
    ( echo "is CONFIG_DEVTMPFS enabled in your kernel?"; emergency_shell )

# mount remaining virtual filesystems
mkdir -p /dev/pts
mkdir -p /dev/shm
mount -a

# create /etc/mtab symlink
ln -fs /proc/mounts /etc/mtab

# ensure hotplog script is disabled even if CONFIG_UEVENT_HELPER is enabled
if [ -f /proc/sys/kernel/hotplug ]; then
    echo "" > /proc/sys/kernel/hotplug
fi


# Declare all variables here.. mostly for housekeeping
init="/sbin/init"
root="/dev/something"
root_rw=""
root_true_rw="ro"
rootflags=""
rootfstype=""
overlayflags=""
to_ram=""
# breakpoints!
#
# right after booting, almost useless, unless theres some module we have to
# load prior to doing anything...?
shell=""
# after waiting for harddrives, udev, lvm work, etc, just prior to mounting
# rootfs
shell_mountdevs=""
# prior to all the sqsh_layer magic... kind of a black box at the moment
shell_sqshprep=""
# just prior to mounting final overlayfs
shell_mountoverlay=""

maint="" # just before switch_root and handover to init
firstboot=""
hoststamp=""
quiet=
verbose=
sqsh_layers=""
sqsh_layerdev=""
sqsh_layerdir="/tmproot"
sqsh_layerdir_rel=""
sqshfstype=""
ram_layer=""
modinject=
fwdev=
initramsys=

# parse our config file, which could possibly override some of our hardcoded
# default behavior
. /ruckusrd.sh

# Parse kernel commandline options
#
# NOTE: By default, when this script hands off control the the underlying
#       root filesystem's init process, the rootfs will be mounted ro.  This
#       behavior can be overriden by passing 'rw' on the kernel command
#       line.
#
# NOTE: rootfstype, rootflags are only applied when mounting the specified root
#       device.  in other words, they are not used when mounting the derivative
#       devices created when we load rootfs into RAM.
for o in `cat /proc/cmdline` ; do
    case $o in 
    init=*)
        init=${o#init=}
        ;;
    quiet)
        quiet=1
        verbose=
        ;;
    verbose)
        verbose=1
        quiet=
        ;;
    to_ram)
        to_ram=1
	;;
    shell)
        shell=1
        ;;
    shell_mountdevs)
        shell_mountdevs=1
        ;;
    shell_sqshprep)
        shell_sqshprep=1
        ;;
    shell_mountoverlay)
        shell_mountoverlay=1
        ;;
    maint)
	maint=1
	;;
    firstboot)
        firstboot=1
        ;;
    rw)
        root_rw=1
        ;;
    root_true_rw)
        root_true_rw="rw"
        ;;
    hoststamp)
        hoststamp=1
        ;;
    blacklist=*)
        blacklist=${o#blacklist=}
        echo "blacklist $blacklist" >> /etc/modprobe.d/ruckusrd-blacklist.conf
        ;;
    root=*)
        root=${o#root=}
        ;;
    rootflags=*)
        rootflags=${o#rootflags=}
        ;;
    rootfstype=*)
        rootfstype=${o#rootfstype=}
        ;;
    overlayflags=*)
        overlayflags=${o#overlayflags=}
        ;;
    sqsh_layers=*)
        sqsh_layers=${o#sqsh_layers=}
        # make layers space-delimited for iterating
        sqsh_layers_ws=${sqsh_layers//:/ }
        ;;
    sqsh_layerdev=*)
        sqsh_layerdev=${o#sqsh_layerdev=}
        sqsh_layerdir="$sqsh_layerdir /sqsh_layerdev"
        ;;
    sqsh_layerdir=*)
        sqsh_layerdir_rel=${o#sqsh_layerdir=}
        ;;
    sqshfstype=*)
        sqshfstype=${o#sqshfstype=}
        ;;
    ram_layer=*)
        ram_layer=${o#ram_layer=}
        ;;
    modinject)
        modinject=1
        ;;
    fwdev=*)
        fwdev=${o#fwdev=}
        ;;
    initramsys)
        initramsys=1
        ;;
    *)
        # NOTE: putting "loop.max_loop=16" in cmdline would cause "options loop
        #       max_loop=16" to get written in modprobe.conf...
        m=$(echo $o |cut -s -d . -f 1)
        opt=$(echo $o |cut -s -d . -f 2-)
        if [ -z "$m" -o -z "$opt" ]; then
          continue
        fi
        p=$(echo $opt |cut -s -d = -f 1)
        v=$(echo $opt |cut -s -d = -f 2-)
        if [ -z "$p" -o -z "$v" ]; then
          continue
        fi
        echo "options $m $p=$v" >> /etc/modprobe.d/ruckusrd-options.conf
        ;;
    esac
done

decho "initramfs created with RuckusRD v$VERSION"

# if user provided sqsh_layerdir, append it to the device mountpoint
if [ -n "$sqsh_layerdir_rel" ]; then
    tmp=
    for x in $sqsh_layerdir; do
        tmp="$tmp $x/$sqsh_layerdir_rel"
    done
    sqsh_layerdir=$tmp
fi

# only pass kernel command line if we're launching /sbin/init
if [ "$init" == "/sbin/init" ] ; then
    initargs=$(cat /proc/cmdline)
else
    initargs=""
fi


decho2 "kernel commandline: `cat /proc/cmdline`"
decho2 "init=$init"
decho2 "root=$root"
decho2 "root_rw=$root_rw"
decho2 "root_true_rw=$root_true_rw"
decho2 "rootflags=$rootflags"
decho2 "rootfstype=$rootfstype"
decho2 "overlayflags=$overlayflags"
decho2 "to_ram=$to_ram"
decho2 "shell=$shell"
decho2 "shell_mountdevs=$shell_mountdevs"
decho2 "shell_sqshprep=$shell_sqshprep"
decho2 "shell_mountoverlay=$shell_mountoverlay"
decho2 "maint=$maint"
decho2 "firstboot=$firstboot"
decho2 "hoststamp=$hoststamp"
decho2 "sqsh_layers=$sqsh_layers"
decho2 "sqsh_layerdev=$sqsh_layerdev"
decho2 "sqsh_layerdir=$sqsh_layerdir"
decho2 "sqsh_layerdir_rel=$sqsh_layerdir_rel"
decho2 "sqshfstype=$sqshfstype"
decho2 "ram_layer=$ram_layer"
decho2 "modinject=$modinject"
decho2 "fwdev=$fwdev"
decho2 "initramsys=$initramsys"


if [ -n "$shell" ]; then
    echo "Dropping directly into shell, as requested.  Enjoy!"
    echo
    control_shell
fi

# load loop module (if not built-in)
#
# NOTE: It doesn't look like losetup triggers an auto-load of the loop module.
#
# FIXME: The CentOS7 kernel has CONFIG_BLK_DEV_LOOP_MIN_COUNT=0... which means
#        modprobing doesn't create any device nodes.  we can either figure out
#        the right way to do this (via loop-control?) or modprobe loop
#        max_loop=32.
#
#        maybe loop-control will autoprobe?
#
#        So, looks like "real" losetup will open /dev/loop-control (which
#        probably triggers modprobe of loop) and does some IOCTLs to create
#        loop device nodes.  I'm guessing the busybox version assumes they're
#        already there.
#
modprobe loop max_loop=32

# extra special device with fw.sqsh on it!
mkdir -p /lib/firmware
if [ -n "$fwdev" ]; then
    # load some modules needed for block device access
    #
    # NOTE: Some is the keyword here.  We need to provide access specifically
    #       to the fwdev here, which wouldn't make sense for some devices
    #       (e.g., floppy, because fwdev needs to be 200-300M).  The likely
    #       scenarios are: 1) SATA disk using AHCI, 2) USB disk, 3) NVME disk,
    #       4) CD/DVD.
    #
    # NOTE: I've always built all the block layer stuff directly into the
    #       kernel because I view it as "core functionality", but we really
    #       want this to work with distro-syle or poorly configured custom
    #       kernels even if they are brain-dead in this regard.
    #
    # scsi disk - should pull in sg, scsi_mod, scsi_common if needed
    modprobe sd_mod
    # scsi cdrom - not sure if it pulls in cdrom, so we add that explicitly
    modprobe sr_mod
    modprobe cdrom
    # sata ahci - should pull in libahci
    modprobe ahci
    # nvme - should pull in nvme_core
    modprobe nvme
    # usb disks - added USB Attached Storage (just in case) and the XHCI PCI
    # driver
    #
    # NOTE: This triggers a couple second long iteration of all the usb devices
    #       detected... so we have to wait for fwdev to show up!
    #
    modprobe usb_storage
    modprobe uas
    modprobe xhci_pci
    # raid - software raid, at least
    modprobe raid1

    # wait for kernel to finish iterating through devices if needed (e.g., USB
    # disks)
    wait_for_dev 10 fwdev $fwdev

    fwdir=/fwdev
    fwsqsh=$fwdir/fw.sqsh
    mkdir -p $fwdir
    # load modules needed for whatever fs is on fwdev
    autoload_fs_module $fwdev
    # mount it
    mount -o ro $fwdev $fwdir
    # mount the fwsqsh file
    #
    # NOTE: This is fatal if missing, so no need to check for existence.
    #
    mkdir -p /lib/firmware
    mount -o ro $fwsqsh /lib/firmware
    # unmount the fwdev since we no longer need to access it
    umount -l $fwdir
fi

# stop normal boot if `initramsys` requested
#
# NOTE: This seems like the perfect `initramsys` spot... fw.sqsh mounted, no
#       special udev rules.
#
if [ -n "$initramsys" ]; then
    decho "starting ruckusrd embedded system"
    start_ruckusrd_system
fi

decho -n "ruckusrd: determining what to mount... "

cat <<EOF > etc/udev/rules.d/99-ruckusrd.rules
ACTION!="add|change", GOTO="ruckusrd_end"
SUBSYSTEM!="block", GOTO="ruckusrd_end"
IMPORT{builtin}="blkid"

EOF

generate_udev_rules root $root
[ -n "$sqsh_layerdev" ] && generate_udev_rules sqsh_layerdev $sqsh_layerdev

cat <<EOF >> etc/udev/rules.d/99-ruckusrd.rules

LABEL="ruckusrd_end"
EOF

decho -en "$thingtomount\n"

start_udev

# wait for at least one harddisk to be handled by udev
#
# NOTE: A full blown settle can take longer than I'd like (~10 seconds).  We
#       can tell udevadm to STOP waiting as soon as a particular device exists,
#       but I can't specify more than one.  So we don't call settle, we loop on
#       our own waiting for /dev/sda or /dev/nvme0n1 (or anything else I decide
#       to wait on in the future).
#
#/sbin/udevadm settle --exit-if-exists=/dev/sda
#
wait_for_dev 10 "at least one hdd" /dev/sda /dev/nvme0n1 /dev/xvda

# activate LVM
#
# NOTE: We activate ALL logical volumes here.  Once our udev rules have created
#       the /dev symlinks we need, we deactivate all the logvols that weren't
#       needed for booting.  Some systems (e.g., fedora and it's cousins) like
#       to hang for 90 seconds flailing around w/ already activated logvols
#       unless we do this.
#
decho2 "activating LVM"
vgchange -a y --quiet --quiet

# do ZFS initialization
#
# NOTE: This ZFS var will be set to the last ZFS= argument to be parsed, so
#       will be set if we have ANY zfs to mount.
#
if [ -n "$ZFS" ]; then
    modprobe zfs
    # NOTE: We're only mounting the specified root dataset here.  The OS will
    #       mount the rest during it's normal bootup processing (assuming it's
    #       configured properly).
    zpool import $ZFS_POOL -N
fi

if [ -z "$thingtomount" ]; then
    # wait for udev symlinks to get created
    dmneeded=""
    wait_for_dev 30 "/dev/root symlink" /dev/root
    root_true=`readlink /dev/root`
    ln -s $root_true /dev/root-true

    # autoload filesystem modules if needed
    if [ -z "$rootfstype" ]; then
        autoload_fs_module /dev/root
        rootfstype=$TYPE
    else
        modprobe $rootfstype
    fi
fi
if [ -n "$sqsh_layerdev" ] && [ -z "$thingtomount_sqsh" ]; then
    wait_for_dev 30 "/dev/sqsh_layerdev symlink" /dev/sqsh_layerdev

    if [ -z "$sqshfstype" ]; then
        autoload_fs_module /dev/sqsh_layerdev
        sqshfstype=$TYPE
    else
        modprobe $sqshfstype
    fi
fi

# deactivate unneeded logvols
#
# FIXME: what if i just deactivate all after mounting /sysroot... will it
#        politely refuse to deactive mounted logvols?
#
decho2 "deactivating unneeded LVM (dmneeded='$dmneeded')"
vgchange -a n --quiet --quiet
for x in $dmneeded; do
    lvchange -a y /dev/mapper/$x --quiet --quiet
done

# run fsck on root dev
#
# NOTE: The root dev becomes impossible to unmount (and thus, impossible to
#       safely fsck) after we pass control over to the host os (unless we load
#       the whole image into RAM).
#
# NOTE: While we do care if this fails, we don't really want a failure to keep
#       the system from booting, especially since an exit status of 1 indicates
#       that fsck found AND SUCCESSFULLY FIXED some errors.
#
# NOTE: Obviously, running fsck on CD/DVD would be dumb.
#
# FIXME: We should really do better fsck error checking (see fsck(8) for exit
#        codes).
#
# FIXME: should we fsck sqsh_layerdev too?  same rationale applies... probably
#        can't umount once we've put things together (unless to_ram?).
#
if ! (echo $root | grep -q "CDLABEL=\|ZFS="); then
    go="fsck -p $thingtomount"
    if [ -n "$quiet" ]; then
        go="$go >/dev/null 2>&1"
    fi
    decho2 $go
    eval $go || echo "WARNING: fsck of rootdev exited non-zero"
fi


# create mountpoints for root and sqsh_layerdev
mkdir -p /sysroot
[ -h /dev/sqsh_layerdev ] && thingtomount_sqsh="/dev/sqsh_layerdev"
[ -n "$thingtomount_sqsh" ] && mkdir -p /sqsh_layerdev

# mountdevs breakpoint
if [ -n "$shell_mountdevs" ]; then
    echo "Dropping into shell prior to mounting device(s), as requested."
    echo
    echo "Prior to exiting, ensure that rootdev is mounted ro at /sysroot, and"
    echo "sqsh_layerdev (if used) is mounted ro at /sqsh_layerdev.  Good luck!"
    echo
    control_shell

else

    mountoptions=" -o ro"
    if [ -n "$rootflags" ]; then
        mountoptions="$mountoptions,$rootflags"
    fi

    go="mount -t $rootfstype $mountoptions $thingtomount /sysroot"
    decho2 $go
    eval $go
    RES=$?

    if [ "$RES" != "0" ] ; then
        echo "---------------------------------"
        echo "WARNING: Cannot mount rootdev!"
        echo "---------------------------------"
        echo
        echo "Dropping to a shell. "
        echo "Mount rootdev ro at /sysroot and exit shell to continue. Good luck!"
        echo
        control_shell
    fi

    # look for sqsh_layerdev
    if [ -n "$thingtomount_sqsh" ]; then
        # NOTE: rootfstype and mountoptions do NOT follow the rootfs rules
        go="mount -t $sqshfstype -o ro $thingtomount_sqsh /sqsh_layerdev"
        decho2 $go
        eval $go
    fi
fi


if [ -n "$sqsh_layers" ]; then
    # move /sysroot to /tmproot so we can do sqsh_layer magic
    decho2 "moving /sysroot to /tmproot"
    mkdir -p /tmproot
    mount --move /sysroot /tmproot

    # sqshprep breakpoint
    if [ -n "$shell_sqshprep" ]; then
        echo "Dropping into shell prior to sqsh_layer prep work, as requested."
        echo
        echo "Prior to exiting, ensure that everything is ready for mounting the final"
        echo "overlay on /sysroot.  If you don't know what that entails, don't break"
        echo "here... :-/"
        echo
        control_shell

    else

        decho2 "setting up sqsh_layers for eventual OverlayFS mount"

        # copy to ram if requested
        #
        # NOTE: We copy them to RAM, but then move the dir they're in to
        #       /mnt/sqsh_layerdev later on so it's available via a visible filesys
        #       for future usage (e.g., creating virtual machines, installing).
        #
        if [ -n "$to_ram" ]; then
            decho -n "ruckusrd: Copying squashfs layer(s) to RAM... "
            mkdir -p /sqsh_layerdev
            decho2 -en "\n"
            go="cp -a"
            [ "$quiet" != "1" ] && go="$go -v"
            for x in $sqsh_layers_ws; do
                go="$go $(lookup_layer $x)"
            done
            go="$go /sqsh_layerdev"
            decho2 $go
            eval $go
	    decho -en "done\n"
            sqsh_layerdir=/sqsh_layerdev
        fi

        # mount individual layers
        #
        # NOTE: We create /dev symlinks here to disguise the loopback device.
        #       W/out it, some systems attempt to unmount loop devices prior to
        #       other filesystems, which leads to problems. (also, it's helpful for
        #       the user to see in df output)
        #
        #       we won't have to worry pre-switchroot paths being incorrect once we
        #       swithcroot.
        #
        for x in $sqsh_layers_ws; do
            loopdev=$(losetup -f)
            losetup $loopdev $(lookup_layer $x)
            ln -s $loopdev /dev/sqsh_layer-$x
            mkdir -p /sqsh_layer-$x
            go="mount -o ro /dev/sqsh_layer-$x /sqsh_layer-$x"
            decho2 $go
            eval $go
        done

        # create ram layer if requested
        if [ -n "$ram_layer" ]; then
            decho2 "creating ram_layer w/ size=$ram_layer"
            mkdir -p /upper
            mount -t tmpfs -o size=$ram_layer ram_layer /upper
            mkdir -p /upper/upper /upper/work
            decho2 "converting retentive upper to non-retentive lower layer"
            mkdir -p /sqsh_layer-upper
            go="mount -o ro,bind /tmproot/upper/upper /sqsh_layer-upper"
            decho2 $go
            eval $go
            sqsh_layers=upper:$sqsh_layers
            sqsh_layers_ws="upper $sqsh_layers_ws"
            upper=upper
        else
            # need to remount rootfs rw so we can write into upper layer
            decho2 "remounting /tmproot rw"
            mount -o remount,rw /tmproot
            mkdir -p /tmproot/upper/upper /tmproot/upper/work
            upper=/tmproot/upper
            # if we're not using ram_layer, we cannot remount sysroot ro later on,
            # so we must change this flag to rw
            root_true_rw=rw
        fi

    fi

    # NOTE: If we've gone through shell_sqshprep, there are a couple unset
    #       variables we need to set before we carry on.
    #
    # FIXME: This is assuming that if you went through shell_sqshprep, you
    #        didn't set up ram_layer.  We could do a bit better, but doing
    #        ram_layer also involves changing sqsh_layers and
    #        sqsh_layers_ws... could be hard to get right.
    #
    if [ -z "$upper" ]; then
        upper=/tmproot/upper
        root_true_rw=rw
    fi

    # mountoverlay breakpoint
    if [ -n "$shell_mountoverlay" ]; then
        echo "Dropping into shell prior to final overlayfs mount, as requested."
        echo
        echo "Prior to exiting, ensure that the final overlay is mounted ro at /sysroot"
        echo
        control_shell

    else

        # mount the merged filesystem
        decho2 "mounting overlayfs at /sysroot"
        lower=/sqsh_layer-${sqsh_layers//:/:/sqsh_layer-}
        layers=lowerdir=$lower,upperdir=$upper/upper,workdir=$upper/work
        if [ -n "$overlayflags" ]; then
            overlayflags=$overlayflags,$layers
        else
            overlayflags=$layers
        fi
        go="mount -t overlay -o $overlayflags rootfs /sysroot"
        decho2 $go
        eval $go
    fi

    # extra sqsh_layer finalization
    decho2 "doing extra sqsh_layer finalization"

    # this leaves us with /boot containing the merged contents of the layers...
    # but the ACTUAL boot files will end up living in /mnt/root-true/boot/...
    # which is confusing.  so lets bind-mount that to /boot.
    #
    # NOTE: we do this unless we're booting to_ram, in which case the boot
    #       files are no longer mounted anywhere once the system boots.
    #
    # FIXME: if to_ram, consider removing /boot (or it's contents) to make it
    #        super obvious that whatever's in /boot wasn't actually used to
    #        boot.
    #
    #        if we were to do that, we'd want to only do it if to_ram AND
    #        ram_layer, otherwise we'll be recording that deletion in upper
    #        (remember, we've got a rw overlay backed by /mnt/root-true/upper).
    #
    # FIXME: this might get wonky on EFI systems that use an ESP of /boot/efi
    #        (ubuntu, maybe redhat)...  is the ESP gets mounted by the actual
    #        host system after handoff (via /etc/fstab), it *should* happily
    #        mount the ESP on top of our bindmounted /boot.
    #
    if [ -z "$to_ram" ]; then
        if [ -n "`find /tmproot -maxdepth 1 -name vmlinuz\* 2>/dev/null`" ]; then
            # there's a kernel directly in /tmproot, so it's probably a /boot
            # partition.  bind mount it as such.
            decho2 "bind mounting /tmproot to /sysroot/boot"
            mount --bind /tmproot /sysroot/boot
        elif [ -n "`find /tmproot/boot -maxdepth 1 -name vmlinuz\* 2>/dev/null`" ]; then
            # there's a kernel inside a boot dir inside /tmproot, bind mount
            # it!
            decho2 "bind mounting /tmproot/boot to /sysroot/boot"
            mount --bind /tmproot/boot /sysroot/boot
        else
            # odd... couldn't find a kernel...?
            #
            # NOTE: This might be totally normal.  Booting UEFI, for example,
            #       could have the kernel and other support files included on
            #       the ESP, which we don't have mounted in here.  If that's
            #       the case, the host sytem will mount the ESP via its fstab
            #       normally.
            #
            decho2 "couldn't find /boot tree to bind mount, but might be fine"
        fi
    fi

    # append a timestamp to system hostname if configured
    if [ -n "$hoststamp" ]; then
        stamp=`date +%s`
        decho2 "appending timestamp to hostname: $stamp"
        if [ -f /sysroot/etc/hostname ]; then
            # systemd
            HOSTNAME=$(cat /sysroot/etc/hostname)-$stamp
            echo $HOSTNAME > /sysroot/etc/hostname
        elif [ -f /sysroot/etc/sysconfig/network ]; then
            # old redhat-ish sysvinit
            . /sysroot/etc/sysconfig/network
            [ -n "$HOSTNAME" ] || break
            for x in /etc/sysconfig/network /etc/hosts; do
                sed -i "s|\($HOSTNAME\)|\1-$stamp|" /sysroot/$x
            done
        fi
    fi

    # get ready to fix mtab
    #
    # NOTE: We can't just forge /etc/mtab at this point, because some systems
    #       sysinit scripts purge old cruft out of that file on the assumption
    #       that the initrd has ONLY mounted /.  So instead, we'll append a
    #       scriptlet that does the forging into rc.local.
    #
    # NOTE: All this mtab forging is completely unneeded on distros that use a
    #       symlink to /proc/mounts for mtab.  This is the case for almost all
    #       distros at this point, but users or buggy scripts could have broken
    #       the symlink.
    #
    # FIXME: At this point, is seems like a safe assumption that all distros
    #        still have rc.local for backwards compatibility...  but you know
    #        how assumptions work....  at some point, we may need to create a
    #        systemd service for this.  (CentOS 7, Ubuntu 18.04, and Ubuntu
    #        20.04 definately all still support rc.local)
    #
    if [ -h /sysroot/etc/mtab ]; then
	RCLOCAL=
    else
	# use /etc/rc.d/rc.local if it exists, otherwise just use /etc/rc.local
	if [ -f /sysroot/etc/rc.d/rc.local ]; then
	    RCLOCAL=/etc/rc.d/rc.local
	else
	    RCLOCAL=/etc/rc.local
	fi
	# create rc.local if needed
	if [ ! -x /sysroot/$RCLOCAL ]; then
	    touch /sysroot/$RCLOCAL
	    chmod +x /sysroot/$RCLOCAL
	fi
	cp /sysroot/$RCLOCAL /sysroot/$RCLOCAL.ruckusrdbak
    fi
    if [ -n "$RCLOCAL" ]; then
	cat <<EOF >> /sysroot/$RCLOCAL
# --- begin ruckusrd appendage ---
EOF
    fi

    # move /sqsh_layerdev into /sysroot
    if [ -d /sqsh_layerdev ]; then
        decho2 "moving /sqsh_layerdev to /sysroot/mnt/"
	mkdir -p /sysroot/mnt/sqsh_layerdev
        mount --move /sqsh_layerdev /sysroot/mnt/sqsh_layerdev
	if [ -n "$RCLOCAL" ]; then
	    cat <<EOF >> /sysroot/$RCLOCAL
echo /dev/sqsh_layerdev /mnt/sqsh_layerdev auto ro 0 0 >> /etc/mtab
EOF
	fi
    fi

    # move individual layer mounts into /sysroot
    for x in $sqsh_layers_ws; do
        decho2 "moving /sqsh_layer-$x to /sysroot/mnt/"
        mkdir -p /sysroot/mnt/sqsh_layer-$x
        mount --move /sqsh_layer-$x /sysroot/mnt/sqsh_layer-$x
        # NOTE: We don't forge mtab entries for these because it just clutters
        #       df output needlessly.
    done

    # move ram layer if needed
    if [ -n "$ram_layer" ]; then
        decho2 "moving /upper to /sysroot/mnt/"
        mkdir -p /sysroot/mnt/upper
        mount --move /upper /sysroot/mnt/upper
        # NOTE: We don't forge an mtab entry for this because overlayfs is
        #       smart enough to always show the stats of upperdir in df output.
    fi

    # Move the old sysroot into the new one, if needed.
    #
    # NOTE: root-true is left mounted unless to_ram was specified, in which
    #       case it is unmounted but the mountpoint is configured in /etc/fstab
    #       for easy re-mounting.
    #
    mkdir -p /sysroot/mnt/root-true
    if [ -z "$to_ram" ]; then
        decho2 "moving /tmproot to /sysroot/mnt/root-true"
	mount --move /tmproot /sysroot/mnt/root-true
        # NOTE: I considered not adding this mtab entry when root-true is being
        #       used for upperdir, because you essentially get root-true's
        #       stats for both rootfs and root-true in df...  but that hides
        #       the fact that our real root device (i.e., boot device) is still
        #       mounted at /mnt/root-true.  Unlike the layers themselves, this
        #       is important to know (e.g., so you can go muck with the
        #       bootloader config).
        #
	if [ -n "$RCLOCAL" ]; then
	    cat <<EOF >> /sysroot/$RCLOCAL
echo /dev/root-true /mnt/root-true auto $root_true_rw 0 0 >> /etc/mtab
EOF
	fi
    else
        # setup easy mounting of /dev/root-true
        #
        # NOTE: we let the fstab injection fail to allow users to put new
        #       copies of fstab in the conf dir... which might overwrite
        #       /sysroot/etc/fstab with a symlink that's broken until we hand
        #       off control via switch_root.
        #
        echo "" >> /sysroot/etc/fstab || decho -n
        echo "/dev/root-true /mnt/root-true auto noauto,$root_true_rw 0 0" >> /sysroot/etc/fstab || decho -n

        # unmount it (so we can eject removable media)
        decho2 "unmounting /tmproot"
        umount /tmproot

        # we copied sqsh_layers into RAM.  make them visible in the baby
        # filesystem at /mnt/sqsh_layerdev
        mkdir -p /sysroot/mnt/sqsh_layerdev
        mount --bind $sqsh_layerdir /sysroot/mnt/sqsh_layerdev
	if [ -n "$RCLOCAL" ]; then
	    cat <<EOF >> /sysroot/$RCLOCAL
echo /dev/sqsh_layerdev /mnt/sqsh_layerdev auto rw 0 0 >> /etc/mtab
EOF
	fi
    fi

    # add some debug output
    if [ "$quiet" != "1" ] && [ -n "$RCLOCAL" ]; then
	cat <<EOF >> /sysroot/$RCLOCAL
echo ---------------
df -h
echo ---------------
mount
echo ---------------
EOF
    fi

    # make sure rc.local doesn't grow into a giant mess
    #
    # NOTE: We made a copy of rc.local before we started appending to it.  This
    #       makes rc.local restore itself to its previous state once it's done
    #       executing our extra lines.
    #
    if [ -n "$RCLOCAL" ]; then
	cat <<EOF >> /sysroot/$RCLOCAL
mv $RCLOCAL.ruckusrdbak $RCLOCAL
EOF
    fi

    # fix unmount chicken-and-the-egg problem
    #
    # NOTE: If not to_ram, the device(s) required to assemble the rootfs end up
    #       getting moved to mountpoints on top of the rootfs in the final
    #       system.  This leaves us with a can't unmount /mnt/sqsh_layerdev
    #       w/out unmounting / first dilemma leading to potential errors and
    #       time-outs during shutdown.  The easy fix is to lazy-unmount the
    #       troublesome devices.  The messy part is how to do it w/out making
    #       assumptions about the system being booted.  We have to register
    #       some sort of script to execute at shutdown, after mostly everything
    #       has finished, but before the system tries to unmount its rootfs.
    #
    if [ -z "$to_ram" ]; then
        # create script
        ruckusrd_umount=/.ruckusrd_umount
        cat <<EOF > /sysroot/$ruckusrd_umount
#!/bin/bash

# quietly umount rootfs dependencies that we left mounted on top of rootfs, so
# that we can umount / eventually.

umount -l /boot

# leave this rw so overlay continues to work...
#mount -o remount,ro /mnt/root-true
umount -l /mnt/root-true

umount -l /mnt/sqsh_layerdev

EOF
        for x in $sqsh_layers_ws; do
            cat <<EOF >> /sysroot/$ruckusrd_umount
umount -l /mnt/sqsh_layer-$x
EOF
        done

        chmod +x /sysroot/$ruckusrd_umount

        # actually make that script get executed on shutdown
        if [ "$(basename $(readlink /sysroot/$init))" != "systemd" ]; then
            # not systemd, assume sysvinit
            ln -fs $ruckusrd_umount /sysroot/etc/rc0.d/S00ruckusrd_halt
            ln -fs $ruckusrd_umount /sysroot/etc/rc6.d/S00ruckusrd_reboot
            # add a couple lines to the script to remove those symlinks, too
            cat <<EOF >> /sysroot/$ruckusrd_umount

rm -f /etc/rc0.d/S00ruckusrd_halt
rm -f /etc/rc6.d/S00ruckusrd_reboot
EOF
        else
            # look up path to systemd services
            #
            # NOTE: We can't do "systemctl show --value -p FragmentPath
            #       halt.target" because systemctl doesn't work until systemd
            #       is running...
            #
            #       this might not be 100% correct, but it's a best guess for
            #       now (and works in Ubuntu).
            #
            systemdpath=$(dirname $(readlink /sysroot/$init))/system
            # if it's a relative path, make it absolute
            if [ -z "$(echo $systemdpath | awk '/^\// {print}')" ]; then
                systemdpath=$(realpath /sysroot/$(dirname $init)/$systemdpath | sed 's|^/sysroot||')
            fi

            # create service file
            cat <<EOF > /sysroot/$systemdpath/ruckusrd_umount.service
[Unit]
Description=RuckusRD sqsh_layer unmount
DefaultDependencies=no
Before=umount.target

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=$ruckusrd_umount

EOF

            # register it for shutdown
            for x in halt poweroff reboot; do
                mkdir -p /sysroot/$systemdpath/$x.target.wants
                ln -fs ../ruckusrd_umount.service /sysroot/$systemdpath/$x.target.wants/ruckusrd_umount.service
            done

            # add a couple lines to the script to remove those symlinks and the
            # service file
            cat <<EOF >> /sysroot/$ruckusrd_umount

for x in halt poweroff reboot; do
    rm -f $systemdpath/\$x.target.wants/ruckusrd_umount.service
done

rm -f $systemdpath/ruckusrd_umount.service
EOF

        fi

        # and add a line to remove the script itself
        cat <<EOF >> /sysroot/$ruckusrd_umount

rm -f $ruckusrd_umount
EOF
    fi

    # and finally, remount /sysroot read-only because most/all systems expect /
    # to be mounted ro prior to their init systems taking over.
    mount -o remount,ro /sysroot
fi

# inject modules/headers/firmware into rootfs
#
# NOTE: We don't want to completely remove and reinstall modules like the old
#       extractenator script was doing.  That would be slow every time, and
#       would remove built out-of-tree modules.  Instead we just want to update
#       via rsync.
#
#       Actually, rsync w/out any actual updates still takes a few
#       seconds... which isn't desirable for every single bootup at all.  As a
#       compromise, we manually check timestamp of /sysroot/lib/modules/VERSION
#       if it exists to see if its older than what's on the initramfs, and if
#       it is, then do an rsync.  Same drill for linux-headers and firmware.
#
if [ -n "$modinject" ]; then
    decho -n "ruckusrd: Injecting kernel modules, headers, and firmware into /sysroot... "
    decho2 -en "\n"
    
    # mount rw
    mount -o remount,rw /sysroot
    
    # figure out version, if we have a .y symlink to manage, etc
    #
    # VERSION will always be set, and it will be a real directory (not a
    # symlink).
    #
    # VERSION_NAME, if set, is the symlink name.
    #
    for x in /lib/modules/*; do
        if [ -h $x ]; then
            VERSION=$(readlink $x)
            VERSION_NAME=$(basename $x)
            break
        else
            VERSION=$(basename $x)
        fi
    done
    decho2 VERSION=$VERSION
    decho2 VERSION_NAME=$VERSION_NAME
    
    # modules - remove old symlinked files if different
    #
    # if we're installing a symlink, and the symlink already exists and points
    # to a different version, remove what it points at and recreate the symlink
    mkdir -p /sysroot/lib/modules
    need_new=
    sysdir=/sysroot/lib/modules/$VERSION
    if [ -n "$VERSION_NAME" ]; then
        syslink=/sysroot/lib/modules/$VERSION_NAME
        if [ -h $syslink ]; then
            old_one=$(readlink $syslink)
            if [ "$old_one" != "$VERSION" ]; then
                decho2 "following $syslink symlink to remove modules in $old_one"
                rm -rf /sysroot/lib/modules/$old_one
                decho2 "removing $syslink symlink"
                rm -f $syslink
            fi
        elif [ -e $syslink ]; then
            decho2 "removing $syslink file/dir"
            rm -rf $syslink
        fi
        if [ ! -h $syslink ]; then
            need_new=y
            go="ln"
            [ "$quiet" != "1" ] && go="$go -v"
            go="$go -s $VERSION $syslink"
            decho2 $go
            eval $go
        fi
    fi
    
    # modules - rsync the new ones
    if [ ! -d "$sysdir" ]; then
        need_new=y
    elif [ /lib/modules/$VERSION -nt "$sysdir" ]; then
        need_new=y
    fi
    if [ -n "$need_new" ]; then
        go="rsync"
        [ "$quiet" != "1" ] && go="$go --stats"
        # don't use -a, because we don't want group or owner preserved
        go="$go -rlptD -u /lib/modules/$VERSION /sysroot/lib/modules/"
        decho2 $go
        eval $go
    fi
    
    # headers will be left out of the initramfs if the kernel doesn't support
    # out-of-tree module buliding (e.g., CONFIG_TRIM_UNUSED_KSYMS=y), so check
    # for these
    if [ -d /usr/src/linux-headers-$VERSION ]; then
        # headers - remove old symlinked files if different
        #
        # if we're installing a symlink, and the symlink already exists and
        # points to a different version, remove what it points at and recreate
        # the symlink
        mkdir -p /sysroot/usr/src
        need_new=
        sysdir=/sysroot/usr/src/linux-headers-$VERSION
        if [ -n "$VERSION_NAME" ]; then
            syslink=/sysroot/usr/src/linux-headers-$VERSION_NAME
            if [ -h $syslink ]; then
                old_one=$(readlink $syslink)
                if [ "$old_one" != "linux-headers-$VERSION" ]; then
                    decho2 "following $syslink symlink to remove headers in $old_one"
                    rm -rf /sysroot/usr/src/$old_one
                    decho2 "removing $syslink symlink"
                    rm -f $syslink
                fi
            elif [ -e $syslink ]; then
                decho2 "removing $syslink file/dir"
                rm -rf $syslink
            fi
            if [ ! -h $syslink ]; then
                need_new=y
                go="ln"
                [ "$quiet" != "1" ] && go="$go -v"
                go="$go -s linux-headers-$VERSION $syslink"
                decho2 $go
                eval $go
            fi
        fi
        
        # headers - rsync the new ones
        if [ ! -d "$sysdir" ]; then
            need_new=y
        elif [ /usr/src/linux-headers-$VERSION -nt "$sysdir" ]; then
            need_new=y
        fi
        if [ -n "$need_new" ]; then
            go="rsync"
            [ "$quiet" != "1" ] && go="$go --stats"
            # don't use -a, because we don't want group or owner preserved
            go="$go -rlptD -u /usr/src/linux-headers-$VERSION /sysroot/usr/src/"
            decho2 $go
            eval $go
        fi
        
    fi
    
    # firmware - rsync the new ones
    sysdir=/sysroot/lib/firmware
    if [ ! -d "$sysdir" ]; then
        need_new=y
    elif [ /lib/firmware -nt "$sysdir" ]; then
        need_new=y
    fi
    if [ -n "$need_new" ]; then
        go="rsync"
        [ "$quiet" != "1" ] && go="$go --stats"
        # don't use -a, because we don't want group or owner preserved
        go="$go -rlptD -u /lib/firmware $(dirname $sysdir)"
        decho2 $go
        eval $go
    fi

    # mount ro
    mount -o remount,ro /sysroot

    decho -en "done\n"
fi


# remount final root dev rw if requested
[ -n "$root_rw" ] && mount -o remount,rw /sysroot

# unmount fw.sqsh if we mounted it
[ -n "$fwsqsh" ] && umount /lib/firmware

if [ -n "$firstboot" ]; then
    mount -o remount,rw /sysroot
    firstboot_wizard
    mount -o remount,ro /sysroot
fi

if [ -n "$maint" ]; then
    echo "Dropping to a maintenance shell, as requested. Good luck!"
    echo
    control_shell
fi

# NOTE: Inside initramfs, prior to switch_root, if $init is a symlink w/
#       absolute path, it will be broken...
init_check=/sysroot$init
if [ -L $init_check -a $(readlink $init_check | head -c1) != "." ]; then
    init_check=/sysroot$(readlink $init_check)
fi
if [ ! -x $init_check ]; then
    echo "---------------------------------------------------------"
    echo "WARNING: Requested $init binary does not exist on rootfs."
    echo "---------------------------------------------------------"
    echo
    echo "Dropping to a shell. Good luck!"
    echo
    control_shell
fi

# Leave initramfs and transition to rootfs
#
# FIXME: mdmon?
#
kill `pidof udevd`

decho2 "switching to real rootfs..."
go="exec switch_root /sysroot $init $initargs"
decho2 $go
eval $go


echo "---------------------------------"
echo "WARNING: Error switching to real rootfs!"
echo "---------------------------------"
echo
echo "Dropping to a shell. Good luck!"
echo
control_shell
