#!/bin/ash
#
# Copyright 2012-2025 Michael D Labriola <veggiemike@sourceruckus.org>
#
# Licensed under the GPLv3. See the file COPYING for details. 
#
# This initramfs /init script is a derivative of the one embedded in mayflower
# (flexible mkinitrd replacement used originally by fedora's livecd-creator,
# David Zeuthen <davidz@redhat.com>).
#
# It's been largely rewritten (multiple times now) to be used as the initramfs
# /init script for a mkinitrd replacement that can be used on embedded systems,
# flash drives, live CDs, and normal desktop Linux systems.  See the file
# README for details.
#
# ---- BUSYBOX COMPAT NOTE ----
# So far, this script uses the following non-basic features that I should
# double-check for busybox applet compatibility moving forward:
#
# - sed -i (yes!)
# - bash ${param#word} and ${param//pattern/string} expansions (yes and yes!)
# - bash trap and set -e (yes!)
# - bash $() command subst (yes!)
# - bash {} globbing (e.g., cp foo{,bak}) (NOPE)
# - bash var+= (NOPE)


# parse our common functions
. /ruckusrd-common.sh


trap "emergency_shell" 0 2

# exit immediately if a command fails
set -e

PATH=/sbin:/bin

exec < /dev/console > /dev/console 2>&1

# before we start mounting anything, let's fix file ownership/perms on the
# entire initramfs.
#
# NOTE: This is needed because in order to be able to create initramfs as
#       non-root users, we cannot change ownership of the files it contains
#       while running ruckusrd.
#
chown -R root:root /
chgrp utmp /var/log/lastlog
chown -R ruckus:users /home/ruckus
chmod u+s /bin/busybox

# mount devtmpfs for /dev
mount -n -t devtmpfs -o mode=0755 devtmpfs /dev || \
    ( echo "is CONFIG_DEVTMPFS enabled in your kernel?"; emergency_shell )

# mount remaining virtual filesystems
mkdir -p /dev/pts
mkdir -p /dev/shm
mount -a

# create /etc/mtab symlink
ln -fs /proc/mounts /etc/mtab

# ensure hotplog script is disabled even if CONFIG_UEVENT_HELPER is enabled
if [ -f /proc/sys/kernel/hotplug ]; then
    echo "" > /proc/sys/kernel/hotplug
fi


# Declare all variables here.. mostly for housekeeping
init="/sbin/init"
root="/dev/something"
root_rw=""
root_true_rw="ro"
rootflags=""
rootfstype=""
overlayflags=""
to_ram=""
# breakpoints!
#
# right after booting, almost useless, unless theres some module we have to
# load prior to doing anything...?
shell=""
# after waiting for harddrives, udev, lvm work, etc, just prior to mounting
# rootfs
shell_mountdevs=""
# prior to all the sqsh_layer magic... kind of a black box at the moment
shell_sqshprep=""
# just prior to mounting final overlayfs
shell_mountoverlay=""

maint="" # just before switch_root and handover to init
firstboot=""
hoststamp=""
quiet=
verbose=
sqsh_layers=""
sqsh_layerdev=""
sqsh_layerdir="/tmproot"
sqsh_layerdir_rel=""
sqshfstype=""
ram_layer=""
modinject=
fwdev=
initramsys=
initramsys_net=
initramsys_net_conf=
modules_early=

# parse our config file, which could possibly override some of our hardcoded
# default behavior
. /ruckusrd.sh

# Parse kernel commandline options
#
# NOTE: By default, when this script hands off control the the underlying
#       root filesystem's init process, the rootfs will be mounted ro.  This
#       behavior can be overriden by passing 'rw' on the kernel command
#       line.
#
# NOTE: rootfstype, rootflags are only applied when mounting the specified root
#       device.  in other words, they are not used when mounting the derivative
#       devices created when we load rootfs into RAM.
#
parse_boot_params

decho "initramfs created with RuckusRD v$VERSION"

if [ -n "$modules_early" ]; then
    decho "early loading modules: $modules_early"
    for m in $modules_early_ws; do
        go="modprobe $m"
        decho2 $go
        eval $go || echo "WARNING: failed to load module $m"
    done
fi

# let's make sure we have usb keyboard support early, no matter what.
modprobe input
modprobe usbcore
modprobe usbhid
modprobe hid-generic

if [ -n "$shell" ]; then
    echo "Dropping directly into shell, as requested.  Enjoy!"
    echo
    control_shell
fi

# load loop module (if not built-in)
#
# NOTE: It doesn't look like losetup triggers an auto-load of the loop module.
#
# FIXME: The CentOS7 kernel has CONFIG_BLK_DEV_LOOP_MIN_COUNT=0... which means
#        modprobing doesn't create any device nodes.  we can either figure out
#        the right way to do this (via loop-control?) or modprobe loop
#        max_loop=32.
#
#        maybe loop-control will autoprobe?
#
#        So, looks like "real" losetup will open /dev/loop-control (which
#        probably triggers modprobe of loop) and does some IOCTLs to create
#        loop device nodes.  I'm guessing the busybox version assumes they're
#        already there.
#
modprobe loop max_loop=32

# extra special device with fw.sqsh on it!
mkdir -p /lib/firmware
if [ -n "$fwdev" ]; then
    # load some modules needed for block device access
    #
    # NOTE: Some is the keyword here.  We need to provide access specifically
    #       to the fwdev here, which wouldn't make sense for some devices
    #       (e.g., floppy, because fwdev needs to be 200-300M).  The likely
    #       scenarios are: 1) SATA disk using AHCI, 2) USB disk, 3) NVME disk,
    #       4) CD/DVD.
    #
    # NOTE: I've always built all the block layer stuff directly into the
    #       kernel because I view it as "core functionality", but we really
    #       want this to work with distro-syle or poorly configured custom
    #       kernels even if they are brain-dead in this regard.
    #
    # scsi disk - should pull in sg, scsi_mod, scsi_common if needed
    modprobe sd_mod
    # scsi cdrom - not sure if it pulls in cdrom, so we add that explicitly
    modprobe sr_mod
    modprobe cdrom
    # sata ahci - should pull in libahci
    modprobe ahci
    # nvme - should pull in nvme_core
    modprobe nvme
    # usb disks - added USB Attached Storage (just in case) and the XHCI PCI
    # driver
    #
    # NOTE: This triggers a couple second long iteration of all the usb devices
    #       detected... so we have to wait for fwdev to show up!
    #
    modprobe usb_storage
    modprobe uas
    modprobe xhci_pci
    # raid - software raid, at least
    modprobe raid1

    # wait for kernel to finish iterating through devices if needed (e.g., USB
    # disks)
    #
    # NOTE: This waits for any of fwdev_ws devices to show up, and sets
    #       /dev/lastwaited symlink to point to whichever one showed up first
    #
    wait_for_dev 10 fwdev $fwdev_ws
    fwdev=$(readlink /dev/lastwaited)

    fwdir=/fwdev
    fwsqsh=$fwdir/fw.sqsh
    mkdir -p $fwdir
    # load modules needed for whatever fs is on fwdev
    autoload_fs_module $fwdev
    # mount it
    mount -o ro $fwdev $fwdir
    # mount the fwsqsh file
    #
    # NOTE: This is fatal if missing, so no need to check for existence.
    #
    mkdir -p /lib/firmware
    mount -o ro $fwsqsh /lib/firmware
fi

# stop normal boot if `initramsys` requested
#
# NOTE: This seems like the perfect `initramsys` spot... fw.sqsh mounted, no
#       special udev rules.
#
if [ -n "$initramsys" ]; then
    decho "starting ruckusrd embedded system"
    start_ruckusrd_system
fi

decho -n "ruckusrd: determining what to mount... "

cat <<EOF > etc/udev/rules.d/99-ruckusrd.rules
ACTION!="add|change", GOTO="ruckusrd_end"
SUBSYSTEM!="block", GOTO="ruckusrd_end"
IMPORT{builtin}="blkid"

EOF

generate_udev_rules root $root
[ -n "$sqsh_layerdev" ] && generate_udev_rules sqsh_layerdev $sqsh_layerdev

cat <<EOF >> etc/udev/rules.d/99-ruckusrd.rules

LABEL="ruckusrd_end"
EOF

decho -en "$thingtomount\n"

start_udev

# wait for at least one harddisk to be handled by udev
#
# NOTE: A full blown settle can take longer than I'd like (~10 seconds).  We
#       can tell udevadm to STOP waiting as soon as a particular device exists,
#       but I can't specify more than one.  So we don't call settle, we loop on
#       our own waiting for /dev/sda or /dev/nvme0n1 (or anything else I decide
#       to wait on in the future).
#
#/sbin/udevadm settle --exit-if-exists=/dev/sda
#
wait_for_dev 10 "at least one hdd" /dev/sda /dev/nvme0n1 /dev/xvda /dev/xvdb /dev/xvdc

# activate LVM
#
# NOTE: We activate ALL logical volumes here.  Once our udev rules have created
#       the /dev symlinks we need, we deactivate all the logvols that weren't
#       needed for booting.  Some systems (e.g., fedora and it's cousins) like
#       to hang for 90 seconds flailing around w/ already activated logvols
#       unless we do this.
#
decho2 "activating LVM"
vgchange -a y --quiet --quiet

# do ZFS initialization
#
# NOTE: This ZFS var will be set to the last ZFS= argument to be parsed, so
#       will be set if we have ANY zfs to mount.
#
if [ -n "$ZFS" ]; then
    modprobe zfs
    # NOTE: We're only mounting the specified root dataset here.  The OS will
    #       mount the rest during it's normal bootup processing (assuming it's
    #       configured properly).
    #
    # FIXME: what's the harm in just letting it mount everything here?
    #
    zpool import $ZFS_POOL -N
fi

# /dev/root will eventually be a symlink pointing to our specified root device
# (unless it's on ZFS), but we have to wait for hotplug events to get processed
# by udev
#
# NOTE: If it's ZFS, we will have already set rootfstype to "zfs", and no udev
#       waiting is needed.
#
decho2 "rootfstype: $rootfstype"
if [ "$rootfstype" != "zfs" ]; then
    wait_for_dev 30 "/dev/root symlink" /dev/root
    root_true=`readlink /dev/root`
    ln -s $root_true /dev/root-true
fi

# autoload filesystem modules if needed
if [ -z "$rootfstype" ]; then
    autoload_fs_module /dev/root
    rootfstype=$TYPE
else
    modprobe $rootfstype
fi

# similarly, if we have a sqsh_layerdev, we need to wait for hotplug
decho2 "sqshfstype: $sqshfstype"
if [ -n "$sqsh_layerdev" ] && [ "$sqshfstype" != "zfs" ]; then
    wait_for_dev 30 "/dev/sqsh_layerdev symlink" /dev/sqsh_layerdev

    if [ -z "$sqshfstype" ]; then
        autoload_fs_module /dev/sqsh_layerdev
        sqshfstype=$TYPE
    else
        modprobe $sqshfstype
    fi
fi

# run fsck on root dev
#
# NOTE: The root dev becomes impossible to unmount (and thus, impossible to
#       safely fsck) after we pass control over to the host os (unless we load
#       the whole image into RAM).
#
# NOTE: While we do care if this fails, we don't really want a failure to keep
#       the system from booting, especially since an exit status of 1 indicates
#       that fsck found AND SUCCESSFULLY FIXED some errors.
#
# NOTE: Obviously, running fsck on CD/DVD would be dumb.
#
# FIXME: We should really do better fsck error checking (see fsck(8) for exit
#        codes).
#
# FIXME: should we fsck sqsh_layerdev too?  same rationale applies... probably
#        can't umount once we've put things together (unless to_ram?).
#
# FIXME: if the rootdev is actually already mounted as /fwdev, and we're going
#        to --move it, it's too late to fsck.  will this fail quietly?
#
if ! (echo $root | grep -q "CDLABEL=\|ZFS="); then
    go="fsck -p $thingtomount"
    if [ -n "$quiet" ]; then
        go="$go >/dev/null 2>&1"
    fi
    decho2 $go
    eval $go || echo "WARNING: fsck of rootdev exited non-zero"
fi


# create mountpoints for root and sqsh_layerdev
mkdir -p /sysroot
[ -h /dev/sqsh_layerdev ] && thingtomount_sqsh="/dev/sqsh_layerdev"
[ -n "$thingtomount_sqsh" ] && mkdir -p /sqsh_layerdev

# mountdevs breakpoint
if [ -n "$shell_mountdevs" ]; then
    echo "Dropping into shell prior to mounting device(s), as requested."
    echo
    echo "Prior to exiting, ensure that rootdev is mounted ro at /sysroot, and"
    echo "sqsh_layerdev (if used) is mounted ro at /sqsh_layerdev.  Good luck!"
    echo
    control_shell

else

    mountoptions=" -o ro"
    if [ -n "$rootflags" ]; then
        mountoptions="$mountoptions,$rootflags"
    fi

    # check to see if $thingtomount is already mounted, and if it is, --bind
    # from the previous mountpoint.  this is possible in the scenario where
    # fw.sqsh is kept on the root device of a sqsh_layer system (e.g.,
    # /mnt/root-true).
    prevmp=$(grep "^$thingtomount" /proc/mounts | awk '{print $2}')
    if [ -n "$prevmp" ]; then
        # NOTE: Testing indicates mountoptions are ignored when using --bind,
        #       so we don't specify them here.
        go="mount --bind $prevmp /sysroot"
    else
        go="mount -t $rootfstype $mountoptions $thingtomount /sysroot"
    fi
    decho2 $go
    eval $go || (
        echo "---------------------------------"
        echo "WARNING: Cannot mount rootdev!"
        echo "---------------------------------"
        echo
        echo "Dropping to a shell. "
        echo "Mount rootdev ro at /sysroot and exit shell to continue. Good luck!"
        echo
        control_shell
    )

    # look for sqsh_layerdev
    if [ -n "$thingtomount_sqsh" ]; then
        # NOTE: rootfstype and mountoptions do NOT follow the rootfs rules
        #
        # check if $thingtomount_sqsh is already mounted, and --bind mount if
        # it is.  this is possible in the scenario where fw.sqsh is kept on
        # sqshlayer_dev.
        #
        prevmp=$(grep "^$thingtomount_sqsh" /proc/mounts | awk '{print $2}')
        if [ -n "$prevmp" ]; then
            # NOTE: Testing indicates mountoptions are ignored when using --bind,
            #       so we don't specify them here.
            go="mount --bind $prevmp /sqsh_layerdev"
        else
            go="mount -t $sqshfstype -o ro $thingtomount_sqsh /sqsh_layerdev"
        fi
        decho2 $go
        eval $go
    fi
fi


if [ -n "$sqsh_layers" ]; then
    # move /sysroot to /tmproot so we can do sqsh_layer magic
    decho2 "moving /sysroot to /tmproot"
    mkdir -p /tmproot
    mount --move /sysroot /tmproot

    # sqshprep breakpoint
    if [ -n "$shell_sqshprep" ]; then
        echo "Dropping into shell prior to sqsh_layer prep work, as requested."
        echo
        echo "Prior to exiting, ensure that everything is ready for mounting the final"
        echo "overlay on /sysroot.  If you don't know what that entails, don't break"
        echo "here... :-/"
        echo
        control_shell

    else

        decho2 "setting up sqsh_layers for eventual OverlayFS mount"

        # copy to ram if requested
        #
        # NOTE: We copy them to RAM, but then move the dir they're in to
        #       /mnt/sqsh_layerdev later on so it's available via a visible filesys
        #       for future usage (e.g., creating virtual machines, installing).
        #
        if [ -n "$to_ram" ]; then
            decho -n "ruckusrd: Copying squashfs layer(s) to RAM... "
            mkdir -p /sqsh_layerdev
            decho2 -en "\n"
            go="cp -a"
            [ "$quiet" != "1" ] && go="$go -v"
            for x in $sqsh_layers_ws; do
                go="$go $(lookup_layer $x)"
            done
            go="$go /sqsh_layerdev"
            decho2 $go
            eval $go
	    decho -en "done\n"
            sqsh_layerdir=/sqsh_layerdev
        fi

        # mount individual layers
        #
        # NOTE: We create /dev symlinks here to disguise the loopback device.
        #       W/out it, some systems attempt to unmount loop devices prior to
        #       other filesystems, which leads to problems. (also, it's helpful for
        #       the user to see in df output)
        #
        #       we won't have to worry pre-switchroot paths being incorrect once we
        #       swithcroot.
        #
        for x in $sqsh_layers_ws; do
            loopdev=$(losetup -f)
            losetup $loopdev $(lookup_layer $x)
            ln -s $loopdev /dev/sqsh_layer-$x
            mkdir -p /sqsh_layer-$x
            go="mount -o ro /dev/sqsh_layer-$x /sqsh_layer-$x"
            decho2 $go
            eval $go
        done

        # create ram layer if requested
        if [ -n "$ram_layer" ]; then
            decho2 "creating ram_layer w/ size=$ram_layer"
            mkdir -p /upper
            mount -t tmpfs -o size=$ram_layer ram_layer /upper
            mkdir -p /upper/upper /upper/work
            decho2 "converting retentive upper to non-retentive lower layer"
            mkdir -p /sqsh_layer-upper
            go="mount -o ro,bind /tmproot/upper/upper /sqsh_layer-upper"
            decho2 $go
            eval $go
            sqsh_layers=upper:$sqsh_layers
            sqsh_layers_ws="upper $sqsh_layers_ws"
            upper=upper
        else
            # need to remount rootfs rw so we can write into upper layer
            decho2 "remounting /tmproot rw"
            mount -o remount,rw /tmproot
            mkdir -p /tmproot/upper/upper /tmproot/upper/work
            upper=/tmproot/upper
            # if we're not using ram_layer, we cannot remount sysroot ro later on,
            # so we must change this flag to rw
            root_true_rw=rw
        fi

    fi

    # NOTE: If we've gone through shell_sqshprep, there are a couple unset
    #       variables we need to set before we carry on.
    #
    # FIXME: This is assuming that if you went through shell_sqshprep, you
    #        didn't set up ram_layer.  We could do a bit better, but doing
    #        ram_layer also involves changing sqsh_layers and
    #        sqsh_layers_ws... could be hard to get right.
    #
    if [ -z "$upper" ]; then
        upper=/tmproot/upper
        root_true_rw=rw
    fi

    # mountoverlay breakpoint
    if [ -n "$shell_mountoverlay" ]; then
        echo "Dropping into shell prior to final overlayfs mount, as requested."
        echo
        echo "Prior to exiting, ensure that the final overlay is mounted ro at /sysroot"
        echo
        control_shell

    else

        # mount the merged filesystem
        decho2 "mounting overlayfs at /sysroot"
        lower=/sqsh_layer-${sqsh_layers//:/:/sqsh_layer-}
        layers=lowerdir=$lower,upperdir=$upper/upper,workdir=$upper/work
        if [ -n "$overlayflags" ]; then
            overlayflags=$overlayflags,$layers
        else
            overlayflags=$layers
        fi
        go="mount -t overlay -o $overlayflags rootfs /sysroot"
        decho2 $go
        eval $go
    fi

    # extra sqsh_layer finalization
    decho2 "doing extra sqsh_layer finalization"

    # this leaves us with /boot containing the merged contents of the layers...
    # but the ACTUAL boot files will end up living in /mnt/root-true/boot/...
    # which is confusing.  so lets bind-mount that to /boot.
    #
    # NOTE: we do this unless we're booting to_ram, in which case the boot
    #       files are no longer mounted anywhere once the system boots.
    #
    # FIXME: if to_ram, consider removing /boot (or it's contents) to make it
    #        super obvious that whatever's in /boot wasn't actually used to
    #        boot.
    #
    #        if we were to do that, we'd want to only do it if to_ram AND
    #        ram_layer, otherwise we'll be recording that deletion in upper
    #        (remember, we've got a rw overlay backed by /mnt/root-true/upper).
    #
    # FIXME: this might get wonky on EFI systems that use an ESP of /boot/efi
    #        (ubuntu, maybe redhat)...  is the ESP gets mounted by the actual
    #        host system after handoff (via /etc/fstab), it *should* happily
    #        mount the ESP on top of our bindmounted /boot.
    #
    if [ -z "$to_ram" ]; then
        if [ -n "`find /tmproot -maxdepth 1 -name vmlinuz\* 2>/dev/null`" ]; then
            # there's a kernel directly in /tmproot, so it's probably a /boot
            # partition.  bind mount it as such.
            decho2 "bind mounting /tmproot to /sysroot/boot"
            mount --bind /tmproot /sysroot/boot
        elif [ -n "`find /tmproot/boot -maxdepth 1 -name vmlinuz\* 2>/dev/null`" ]; then
            # there's a kernel inside a boot dir inside /tmproot, bind mount
            # it!
            decho2 "bind mounting /tmproot/boot to /sysroot/boot"
            mount --bind /tmproot/boot /sysroot/boot
        else
            # odd... couldn't find a kernel...?
            #
            # NOTE: This might be totally normal.  Booting UEFI, for example,
            #       could have the kernel and other support files included on
            #       the ESP, which we don't have mounted in here.  If that's
            #       the case, the host sytem will mount the ESP via its fstab
            #       normally.
            #
            decho2 "couldn't find /boot tree to bind mount, but might be fine"
        fi
    fi

    # append a timestamp to system hostname if configured
    if [ -n "$hoststamp" ]; then
        stamp=`date +%s`
        decho2 "appending timestamp to hostname: $stamp"
        if [ -f /sysroot/etc/hostname ]; then
            # systemd
            HOSTNAME=$(cat /sysroot/etc/hostname)-$stamp
            echo $HOSTNAME > /sysroot/etc/hostname
        elif [ -f /sysroot/etc/sysconfig/network ]; then
            # old redhat-ish sysvinit
            . /sysroot/etc/sysconfig/network
            [ -n "$HOSTNAME" ] || break
            for x in /etc/sysconfig/network /etc/hosts; do
                sed -i "s|\($HOSTNAME\)|\1-$stamp|" /sysroot/$x
            done
        fi
    fi

    # get ready to fix mtab
    #
    # NOTE: We can't just forge /etc/mtab at this point, because some systems
    #       sysinit scripts purge old cruft out of that file on the assumption
    #       that the initrd has ONLY mounted /.  So instead, we'll append a
    #       scriptlet that does the forging into rc.local.
    #
    # NOTE: All this mtab forging is completely unneeded on distros that use a
    #       symlink to /proc/mounts for mtab.  This is the case for almost all
    #       distros at this point, but users or buggy scripts could have broken
    #       the symlink.
    #
    # FIXME: At this point, is seems like a safe assumption that all distros
    #        still have rc.local for backwards compatibility...  but you know
    #        how assumptions work....  at some point, we may need to create a
    #        systemd service for this.  (CentOS 7, Ubuntu 18.04, and Ubuntu
    #        20.04 definately all still support rc.local)
    #
    if [ -h /sysroot/etc/mtab ]; then
	RCLOCAL=
    else
	# use /etc/rc.d/rc.local if it exists, otherwise just use /etc/rc.local
	if [ -f /sysroot/etc/rc.d/rc.local ]; then
	    RCLOCAL=/etc/rc.d/rc.local
	else
	    RCLOCAL=/etc/rc.local
	fi
	# create rc.local if needed
	if [ ! -x /sysroot/$RCLOCAL ]; then
	    touch /sysroot/$RCLOCAL
	    chmod +x /sysroot/$RCLOCAL
	fi
	cp /sysroot/$RCLOCAL /sysroot/$RCLOCAL.ruckusrdbak
    fi
    if [ -n "$RCLOCAL" ]; then
	cat <<EOF >> /sysroot/$RCLOCAL
# --- begin ruckusrd appendage ---
EOF
    fi

    # move /sqsh_layerdev into /sysroot
    if [ -d /sqsh_layerdev ]; then
        decho2 "moving /sqsh_layerdev to /sysroot/mnt/"
	mkdir -p /sysroot/mnt/sqsh_layerdev
        mount --move /sqsh_layerdev /sysroot/mnt/sqsh_layerdev
	if [ -n "$RCLOCAL" ]; then
	    cat <<EOF >> /sysroot/$RCLOCAL
echo /dev/sqsh_layerdev /mnt/sqsh_layerdev auto ro 0 0 >> /etc/mtab
EOF
	fi
    fi

    # move individual layer mounts into /sysroot
    for x in $sqsh_layers_ws; do
        decho2 "moving /sqsh_layer-$x to /sysroot/mnt/"
        mkdir -p /sysroot/mnt/sqsh_layer-$x
        mount --move /sqsh_layer-$x /sysroot/mnt/sqsh_layer-$x
        # NOTE: We don't forge mtab entries for these because it just clutters
        #       df output needlessly.
    done

    # move ram layer if needed
    if [ -n "$ram_layer" ]; then
        decho2 "moving /upper to /sysroot/mnt/"
        mkdir -p /sysroot/mnt/upper
        mount --move /upper /sysroot/mnt/upper
        # NOTE: We don't forge an mtab entry for this because overlayfs is
        #       smart enough to always show the stats of upperdir in df output.
    fi

    # Move the old sysroot into the new one, if needed.
    #
    # NOTE: root-true is left mounted unless to_ram was specified, in which
    #       case it is unmounted but the mountpoint is configured in /etc/fstab
    #       for easy re-mounting.
    #
    mkdir -p /sysroot/mnt/root-true
    if [ -z "$to_ram" ]; then
        decho2 "moving /tmproot to /sysroot/mnt/root-true"
	mount --move /tmproot /sysroot/mnt/root-true
        # NOTE: I considered not adding this mtab entry when root-true is being
        #       used for upperdir, because you essentially get root-true's
        #       stats for both rootfs and root-true in df...  but that hides
        #       the fact that our real root device (i.e., boot device) is still
        #       mounted at /mnt/root-true.  Unlike the layers themselves, this
        #       is important to know (e.g., so you can go muck with the
        #       bootloader config).
        #
	if [ -n "$RCLOCAL" ]; then
	    cat <<EOF >> /sysroot/$RCLOCAL
echo /dev/root-true /mnt/root-true auto $root_true_rw 0 0 >> /etc/mtab
EOF
	fi
    else
        # setup easy mounting of /dev/root-true
        #
        # NOTE: we let the fstab injection fail to allow users to put new
        #       copies of fstab in the conf dir... which might overwrite
        #       /sysroot/etc/fstab with a symlink that's broken until we hand
        #       off control via switch_root.
        #
        echo "" >> /sysroot/etc/fstab || decho -n
        echo "/dev/root-true /mnt/root-true auto noauto,$root_true_rw 0 0" >> /sysroot/etc/fstab || decho -n

        # unmount it (so we can eject removable media)
        decho2 "unmounting /tmproot"
        umount /tmproot

        # we copied sqsh_layers into RAM.  make them visible in the baby
        # filesystem at /mnt/sqsh_layerdev
        mkdir -p /sysroot/mnt/sqsh_layerdev
        mount --bind $sqsh_layerdir /sysroot/mnt/sqsh_layerdev
	if [ -n "$RCLOCAL" ]; then
	    cat <<EOF >> /sysroot/$RCLOCAL
echo /dev/sqsh_layerdev /mnt/sqsh_layerdev auto rw 0 0 >> /etc/mtab
EOF
	fi
    fi

    # add some debug output
    if [ "$quiet" != "1" ] && [ -n "$RCLOCAL" ]; then
	cat <<EOF >> /sysroot/$RCLOCAL
echo ---------------
df -h
echo ---------------
mount
echo ---------------
EOF
    fi

    # make sure rc.local doesn't grow into a giant mess
    #
    # NOTE: We made a copy of rc.local before we started appending to it.  This
    #       makes rc.local restore itself to its previous state once it's done
    #       executing our extra lines.
    #
    if [ -n "$RCLOCAL" ]; then
	cat <<EOF >> /sysroot/$RCLOCAL
mv $RCLOCAL.ruckusrdbak $RCLOCAL
EOF
    fi

    # fix unmount chicken-and-the-egg problem
    #
    # NOTE: If not to_ram, the device(s) required to assemble the rootfs end up
    #       getting moved to mountpoints on top of the rootfs in the final
    #       system.  This leaves us with a can't unmount /mnt/sqsh_layerdev
    #       w/out unmounting / first dilemma leading to potential errors and
    #       time-outs during shutdown.  The easy fix is to lazy-unmount the
    #       troublesome devices.  The messy part is how to do it w/out making
    #       assumptions about the system being booted.  We have to register
    #       some sort of script to execute at shutdown, after mostly everything
    #       has finished, but before the system tries to unmount its rootfs.
    #
    if [ -z "$to_ram" ]; then
        # create script
        ruckusrd_umount=/.ruckusrd_umount
        cat <<EOF > /sysroot/$ruckusrd_umount
#!/bin/bash

# quietly umount rootfs dependencies that we left mounted on top of rootfs, so
# that we can umount / eventually.

umount -l /boot

# leave this rw so overlay continues to work...
#mount -o remount,ro /mnt/root-true
umount -l /mnt/root-true

umount -l /mnt/sqsh_layerdev

EOF
        for x in $sqsh_layers_ws; do
            cat <<EOF >> /sysroot/$ruckusrd_umount
umount -l /mnt/sqsh_layer-$x
EOF
        done

        chmod +x /sysroot/$ruckusrd_umount

        # actually make that script get executed on shutdown
        if [ "$(basename $(readlink /sysroot/$init))" != "systemd" ]; then
            # not systemd, assume sysvinit
            ln -fs $ruckusrd_umount /sysroot/etc/rc0.d/S00ruckusrd_halt
            ln -fs $ruckusrd_umount /sysroot/etc/rc6.d/S00ruckusrd_reboot
            # add a couple lines to the script to remove those symlinks, too
            cat <<EOF >> /sysroot/$ruckusrd_umount

rm -f /etc/rc0.d/S00ruckusrd_halt
rm -f /etc/rc6.d/S00ruckusrd_reboot
EOF
        else
            # look up path to systemd services
            #
            # NOTE: We can't do "systemctl show --value -p FragmentPath
            #       halt.target" because systemctl doesn't work until systemd
            #       is running...
            #
            #       this might not be 100% correct, but it's a best guess for
            #       now (and works in Ubuntu).
            #
            systemdpath=$(dirname $(readlink /sysroot/$init))/system
            # if it's a relative path, make it absolute
            if [ -z "$(echo $systemdpath | awk '/^\// {print}')" ]; then
                systemdpath=$(realpath /sysroot/$(dirname $init)/$systemdpath | sed 's|^/sysroot||')
            fi

            # create service file
            cat <<EOF > /sysroot/$systemdpath/ruckusrd_umount.service
[Unit]
Description=RuckusRD sqsh_layer unmount
DefaultDependencies=no
Before=umount.target

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=$ruckusrd_umount

EOF

            # register it for shutdown
            for x in halt poweroff reboot; do
                mkdir -p /sysroot/$systemdpath/$x.target.wants
                ln -fs ../ruckusrd_umount.service /sysroot/$systemdpath/$x.target.wants/ruckusrd_umount.service
            done

            # add a couple lines to the script to remove those symlinks and the
            # service file
            cat <<EOF >> /sysroot/$ruckusrd_umount

for x in halt poweroff reboot; do
    rm -f $systemdpath/\$x.target.wants/ruckusrd_umount.service
done

rm -f $systemdpath/ruckusrd_umount.service
EOF

        fi

        # and add a line to remove the script itself
        cat <<EOF >> /sysroot/$ruckusrd_umount

rm -f $ruckusrd_umount
EOF
    fi

    # and finally, remount /sysroot read-only because most/all systems expect /
    # to be mounted ro prior to their init systems taking over.
    mount -o remount,ro /sysroot
fi

# inject modules/headers/firmware into rootfs
#
# NOTE: We don't want to completely remove and reinstall modules like the old
#       extractenator script was doing.  That would be slow every time, and
#       would remove built out-of-tree modules.  Instead we just want to update
#       via rsync.
#
#       Actually, rsync w/out any actual updates still takes a few
#       seconds... which isn't desirable for every single bootup at all.  As a
#       compromise, we manually check timestamp of /sysroot/lib/modules/VERSION
#       if it exists to see if its older than what's on the initramfs, and if
#       it is, then do an rsync.  Same drill for linux-headers and firmware.
#
if [ -n "$modinject" ]; then
    decho -n "ruckusrd: Injecting kernel modules, headers, and firmware into /sysroot... "
    decho2 -en "\n"
    
    # mount rw
    mount -o remount,rw /sysroot
    
    # figure out version, if we have a .y symlink to manage, etc
    #
    # VERSION will always be set, and it will be a real directory (not a
    # symlink).
    #
    # VERSION_NAME, if set, is the symlink name.
    #
    for x in /lib/modules/*; do
        if [ -h $x ]; then
            VERSION=$(readlink $x)
            VERSION_NAME=$(basename $x)
            break
        else
            VERSION=$(basename $x)
        fi
    done
    decho2 VERSION=$VERSION
    decho2 VERSION_NAME=$VERSION_NAME
    
    # modules - remove old symlinked files if different
    #
    # if we're installing a symlink, and the symlink already exists and points
    # to a different version, remove what it points at and recreate the symlink
    mkdir -p /sysroot/lib/modules
    need_new=
    sysdir=/sysroot/lib/modules/$VERSION
    if [ -n "$VERSION_NAME" ]; then
        syslink=/sysroot/lib/modules/$VERSION_NAME
        if [ -h $syslink ]; then
            old_one=$(readlink $syslink)
            if [ "$old_one" != "$VERSION" ]; then
                decho2 "following $syslink symlink to remove modules in $old_one"
                rm -rf /sysroot/lib/modules/$old_one
                decho2 "removing $syslink symlink"
                rm -f $syslink
            fi
        elif [ -e $syslink ]; then
            decho2 "removing $syslink file/dir"
            rm -rf $syslink
        fi
        if [ ! -h $syslink ]; then
            need_new=y
            go="ln"
            [ "$quiet" != "1" ] && go="$go -v"
            go="$go -s $VERSION $syslink"
            decho2 $go
            eval $go
        fi
    fi
    
    # modules - rsync the new ones
    if [ ! -d "$sysdir" ]; then
        need_new=y
    elif [ /lib/modules/$VERSION -nt "$sysdir" ]; then
        need_new=y
    fi
    if [ -n "$need_new" ]; then
        go="rsync"
        [ "$quiet" != "1" ] && go="$go --stats"
        # don't use -a, because we don't want group or owner preserved
        go="$go -rlptD -u /lib/modules/$VERSION /sysroot/lib/modules/"
        decho2 $go
        eval $go
    fi
    
    # headers will be left out of the initramfs if the kernel doesn't support
    # out-of-tree module buliding (e.g., CONFIG_TRIM_UNUSED_KSYMS=y), so check
    # for these
    if [ -d /usr/src/linux-headers-$VERSION ]; then
        # headers - remove old symlinked files if different
        #
        # if we're installing a symlink, and the symlink already exists and
        # points to a different version, remove what it points at and recreate
        # the symlink
        mkdir -p /sysroot/usr/src
        need_new=
        sysdir=/sysroot/usr/src/linux-headers-$VERSION
        if [ -n "$VERSION_NAME" ]; then
            syslink=/sysroot/usr/src/linux-headers-$VERSION_NAME
            if [ -h $syslink ]; then
                old_one=$(readlink $syslink)
                if [ "$old_one" != "linux-headers-$VERSION" ]; then
                    decho2 "following $syslink symlink to remove headers in $old_one"
                    rm -rf /sysroot/usr/src/$old_one
                    decho2 "removing $syslink symlink"
                    rm -f $syslink
                fi
            elif [ -e $syslink ]; then
                decho2 "removing $syslink file/dir"
                rm -rf $syslink
            fi
            if [ ! -h $syslink ]; then
                need_new=y
                go="ln"
                [ "$quiet" != "1" ] && go="$go -v"
                go="$go -s linux-headers-$VERSION $syslink"
                decho2 $go
                eval $go
            fi
        fi
        
        # headers - rsync the new ones
        if [ ! -d "$sysdir" ]; then
            need_new=y
        elif [ /usr/src/linux-headers-$VERSION -nt "$sysdir" ]; then
            need_new=y
        fi
        if [ -n "$need_new" ]; then
            go="rsync"
            [ "$quiet" != "1" ] && go="$go --stats"
            # don't use -a, because we don't want group or owner preserved
            go="$go -rlptD -u /usr/src/linux-headers-$VERSION /sysroot/usr/src/"
            decho2 $go
            eval $go
        fi
        
    fi
    
    # firmware - rsync the new ones
    sysdir=/sysroot/lib/firmware
    if [ ! -d "$sysdir" ]; then
        need_new=y
    elif [ /lib/firmware -nt "$sysdir" ]; then
        need_new=y
    fi
    if [ -n "$need_new" ]; then
        go="rsync"
        [ "$quiet" != "1" ] && go="$go --stats"
        # don't use -a, because we don't want group or owner preserved
        go="$go -rlptD -u /lib/firmware $(dirname $sysdir)"
        decho2 $go
        eval $go
    fi

    # mount ro
    mount -o remount,ro /sysroot

    decho -en "done\n"
fi


# remount final root dev rw if requested
[ -n "$root_rw" ] && mount -o remount,rw /sysroot

# unmount fw.sqsh if we mounted it
[ -n "$fwsqsh" ] && umount /lib/firmware

# likewise, unmount fwdev if we mounted it
[ -n "$fwdir" ] && umount $fwdir

# FIXME: This works well enough now, I'm considering making it on by
#        default... perhaps with a 'nofirstboot' to disable it, although that
#        seems like overkill...
#
if [ -n "$firstboot" ]; then
    mount -o remount,rw /sysroot
    # NOTE: When run directly by init, any keypress (including arrow keys)
    #       causes an error exit... but if you run it by hand immediately
    #       afterwards, it works fine.  Running via the setsid cttyhack like we
    #       do for our bash sessions seems to fix it.
    setsid cttyhack env LESS=-cMR firstboot_wizard || echo -n # so exit doesn't trip emergency_shell
    mount -o remount,ro /sysroot
fi

# deactivate unneeded logvols
#
# NOTE: We have to loop over a list of unused logvols to deactivate, because we
#       can't just do a `vgchange -a n` (that refuses to deactivate anything
#       unless it can deactivate EVERYTHING).
#
decho2 "deactivating unneeded LVM"
for lv in $(lvs --noheadings --options vg_name,lv_name --separator=/ --select lv_device_open!=yes); do
    # NOTE: We already know the lv is unused, so this shouldn't ever fail, but
    #       just in case we'll give the user some indication of what's going on.
    lvchange -a n --quiet --quiet $lv || (
        echo "---------------------------------"
        echo "WARNING: Failed to deactivate unused logvol $lv"
        echo "---------------------------------"
        echo
        echo "Dropping to a shell to investigate."
        echo "When done, exit the shell to continue. Good luck!"
        echo
        control_shell
    )
done

if [ -n "$maint" ]; then
    echo "Dropping to a maintenance shell, as requested. Good luck!"
    echo
    control_shell
fi

# NOTE: Inside initramfs, prior to switch_root, if $init is a symlink w/
#       absolute path, it will be broken...
init_check=/sysroot$init
if [ -L $init_check -a $(readlink $init_check | head -c1) != "." ]; then
    init_check=/sysroot$(readlink $init_check)
fi
if [ ! -x $init_check ]; then
    echo "---------------------------------------------------------"
    echo "WARNING: Requested $init binary does not exist on rootfs."
    echo "---------------------------------------------------------"
    echo
    echo "Dropping to a shell. Good luck!"
    echo
    control_shell
fi

# Leave initramfs and transition to rootfs
#
# FIXME: mdmon?
#
kill `pidof udevd`

decho2 "switching to real rootfs..."
go="exec switch_root /sysroot $init $initargs"
decho2 $go
eval $go


echo "---------------------------------"
echo "WARNING: Error switching to real rootfs!"
echo "---------------------------------"
echo
echo "Dropping to a shell. Good luck!"
echo
control_shell
