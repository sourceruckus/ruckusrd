#!/bin/bash
#
# RuckusRD - a super awesome, yet simple, mkinitrd replacement
#
# Copyright 2012-2021 Michael D Labriola <michael.d.labriola@gmail.com>
#
# Licensed under the GPLv3. See the file COPYING for details. 
#
# This script is a derivative of fedora's livecd-creator's mayflower script,
# written by David Zeuthen <davidz@redhat.com>.
#
# It's been largely rewritten (multiple times now) to be a mkinitrd replacement
# that can be used on embedded systems, flash drives, live CDs, and normal
# desktop Linux systems.  See the file README for details.


shopt -s nullglob


# assume we're in the source tree if $PWD/linuxrc exists
if [ -f $(dirname $0)/linuxrc ]; then
    LIBDIR=$(realpath $(dirname $0))
else
    LIBDIR=__LIBDIR__
fi
. $LIBDIR/ruckusrd.conf


decho()
{
    if [ "$opt_verbose" != "0" ]; then
        echo "$*"
    fi
}


usage()
{
    echo "RuckusRD v$VERSION - a super awesome, yet simple, mkinitrd replacement"
    echo "Copyright (C) 2012-2021 Michael D Labriola <michael.d.labriola@gmail.com>"
    echo
    echo "usage: $(basename $0) [--help] [--verbose] [--version] [-f] [-b basedir] [-c best|fast] [-o linuxrc-option] <out-initrd-image> <kernel-version>"
    echo
    echo "example: $(basename $0) /boot/myinitramfs.img \`uname -r\`"
}


# FIXME: so, we need to audit this a bit... removing the tmpdir on failure
#        keeps us from littering /tmp with tons of garbage, but it also
#        prevents us from actually debugging problems.  perhaps just cleanup if
#        it's some type of user error?
#
cleanup()
{
    retcode=$1
    rm -rf $TEMPDIR
    exit $retcode
}


opt_allow_overwrite=0
opt_verbose=0
INITRAMFS_TARGET=""
KERNEL=""
BASEDIR="/"
COMPMODE="fast"
LINUXRC_OPTS=
while [ $# -gt 0 ] ; do
    case $1 in
        --help)
            usage
            exit 0
            ;;
	-V|--version)
	    echo v$VERSION
	    exit 0
	    ;;
        -f)
            opt_allow_overwrite=1
            ;;
        -v|--verbose)
            opt_verbose=1
            ;;
        -b)
            BASEDIR=$2
            shift
            ;;
        -c)
            COMPMODE=$2
            shift
            ;;
        -o)
            LINUXRC_OPTS+=" $2"
            shift
            ;;
        *)
            if [ -z "$INITRAMFS_TARGET" ] ; then
                INITRAMFS_TARGET=$1
            elif [ -z "$KERNEL" ] ; then
                KERNEL=$1
            else
                echo "Unknown option or parameter \"$1\""
                echo
                usage
                exit 1
            fi
            ;;
        *)
            ;;
    esac

    shift
done

if [ -z "$INITRAMFS_TARGET" -o -z "$KERNEL" ] ; then
    usage
    exit 1
fi

if [  "$opt_allow_overwrite" == "0" ] ; then
    if [ -e $INITRAMFS_TARGET ] ; then
	echo "Image $INITRAMFS_TARGET already exists. Use -f to overwrite"
	exit 1
    fi
fi

echo "Building an initramfs at $INITRAMFS_TARGET for kernel $KERNEL"


original_pwd=$PWD

cp="cp -a"
cpio="cpio"
mkdir="mkdir -p"
mv="mv"
xz="xz"
ln="ln"
if [ "$opt_verbose" != "0" ]; then
    cp+=" -v"
    mkdir+=" -v"
    mv+=" -v"
    xz+=" -v"
    ln+=" -v"
else
    cpio+=" --quiet"
fi

decho '********** PREPPING TEMPDIR ****************************************************'
# setup our working tempdir
TEMPDIR=`mktemp -dt ruckusrd-XXXX` &&
$mkdir $TEMPDIR/initramfs || cleanup 1

# populate initramfs w/ pregenerted archive
pushd >/dev/null $TEMPDIR/initramfs &&
$xz -dc $LIBDIR/initramfs.cpio.xz | $cpio --extract &&
popd >/dev/null || cleanup 1

# append to config file
for x in $LINUXRC_OPTS; do
    echo $x >> $TEMPDIR/initramfs/ruckusrd.conf
done
if [ "$opt_verbose" != 0 ]; then
    echo '********** /ruckusrd.conf ******************************************************'
    cat $TEMPDIR/initramfs/ruckusrd.conf
fi


decho '********** INSTALLING MICROCODE ************************************************'
# Copy intel and amd microcode over
#
# NOTE: The microcode has to be in the initramfs for early loading to work.  As
#       with modules, we want this to be a one-size-fits all initrd, so we copy
#       it all despite size and speed penalties.
#
# FIXME: My testing indicates problems finding microcode if compressed, at
#        least on my laptop with zstd.  If I provide just the correct firmware
#        (not the whole catted superblob) as GenuineIntel.bin as first initrd
#        uncompressed, it works fine.  If I compress that w/ zstd, no dice.
#
#        Seems like we're going to fall back to creating microcode.img via
#        subprojects/Makefile.am like fw.sqsh and leave it to the user to
#        install that file in /boot and tweak kernel commandline to put it as
#        the first initrd.
#
#        Also, Xen behaves differently.  ucode=file can be done with EFI .cfg,
#        but it expects a binary file (not cpio), hypervisor arg ucode=scan
#        will look through initrd but when using EFI it can only take one (and
#        I don't want an uncompressed initiramfs).  I need to find out if the
#        binary format can be both AMD/Intel or wether we need to be specific,
#        if we're host specific we may as well just get the micorocde for this
#        particular host.
#
#        We should look into making a multi-part cpio archive.  There's
#        probably a proper name for that.  I know there's a way to combine
#        multip cpio archives into a single file... if each piece can be
#        compressed differently, that may be the perfect solution.  We could
#        have a single file (so Xen EFI .cfg can be happy), we can rely on the
#        kernel's micorocde loader (which can parse through both AMD and Intel
#        files), and we can still compress the majority of the initramfs.
#
#        That was stupid easy: cat ucode.img initrd.img > initrd-combined.img
#
#        Should we
#
#        1) Build ucode.img via subprojects/Makefile.am and install it in
#        /usr/share/ruckusrd to be pulled in by ruckusrd at runtime?
#
#        2) Build it via subprojects/Makefile.am, let the user do what they
#        want with it, have kernel_installer notice /boot/ucode-ruckusrd.img
#        and combine that with initrd at install time?
#
#        3) Build it via subprojects/Makefile.am, assume the user puts it in
#        /boot if they want to use it, have ruckusrd automatically combine that
#        with the initrd it's creating at runtime?
#
#        This really boils down to "do we combine once for our universal
#        initramfs" or "do we combine at install time"?  Not all boxes need
#        microcode (e.g., virtual machines), so leaving it to install-time
#        might allow those boxes to boot faster (but is that even going to be
#        measurable?).  If we do it at install time, and we're requiring each
#        machine that wants ucode to set things up, then why not have them
#        create a smaller machine-specific ucode.img w/ microcodenator instead?
#
#        I'm leaning towards option 1 or 3 for a universal initramfs.  Aaaand
#        now leaning towards 1 becasue we've so far not trusted system's
#        /lib/firmware and we track our own using subprojects.  The down-side
#        is that our firmware update mechanism will be rebuild ruckusrd...
#        perhaps we can add a ruckusrd --update-firmware flag in the future to
#        update those files?  If those files are getting updated, should they
#        go in /var/lib or something like that instead of /usr/share?
#
#        Also, what do the roles of firmwarenator and microcodenator become?
#        Small, machine-specific fw.img and ucode.img generation?  Maybe they
#        should be used post-installation of ruckusrd to create/update fw.sqsh
#        and ucode.img?  Perhaps with --specific and --universal flags?
#
# FIXME: Intel: cating together into bin works, but iucode_tool definately
#        produces something slightly different... and i don't know why.
#
#DESTFWDIR=$TEMPDIR/initramfs/kernel/x86/microcode
#$mkdir -p $DESTFWDIR
#cat /lib/firmware/amd-ucode/microcode*.bin > $DESTFWDIR/AuthenticAMD.bin || cleanup 1
##cat /lib/firmware/intel-ucode{,-with-caveats}/* > $DESTFWDIR/GenuineIntel.bin || cleanup 1
#iucode_tool -w$DESTFWDIR/GenuineIntel.bin /lib/firmware/intel-ucode{,-with-caveats}/ || cleanup 1
#

decho '********** PREPPING INITRAMFS MODULE DIR ***************************************'
HOSTMODDIR=$(realpath -s $BASEDIR/lib/modules/$KERNEL)
decho HOSTMODDIR=$HOSTMODDIR
if [ -h $HOSTMODDIR ]; then
    HOSTMODDIR=$(realpath $HOSTMODDIR)
    decho HOSTMODDIR is a symlink pointing to $HOSTMODDIR
    DESTMODDIR=$TEMPDIR/initramfs/lib/modules/$(basename $HOSTMODDIR)
    decho DESTMODDIR=$DESTMODDIR
    $mkdir $(dirname $DESTMODDIR) || cleanup 1
    $ln -s $(basename $HOSTMODDIR) $TEMPDIR/initramfs/lib/modules/$KERNEL || cleanup 1
else
    DESTMODDIR=$TEMPDIR/initramfs/lib/modules/$KERNEL
    decho DESTMODDIR=$DESTMODDIR
    $mkdir $(dirname $DESTMODDIR) || cleanup 1
fi


decho '********** INSTALLING MODULES **************************************************'
# Copy entire modules dir over
#
# NOTE: Now that we're copying the entire tree as-is, we no longer have to
#       search for missing dependencies or rerun depmod.
#
# FIXME: maybe this shouldn't be the default behavior?  allow command line flag
#        to do subset of modules? --only-needed-modules?
#
$cp -a $(realpath $HOSTMODDIR) $DESTMODDIR || cleanup 1


# FIXME: skip this whole thing if CONFIG_TRIM_UNUSED_KSYMS=y
config=$BASEDIR/boot/config-$KERNEL
no_headers=
if [ ! -f $config ]; then
    echo "WARNING: kernel config $config missing, assuming CONFIG_TRIM_UNUSED_KSYMS unset"
else
    no_headers=$(grep CONFIG_TRIM_UNUSED_KSYMS=y $config)
fi
if [ -n "$no_headers" ]; then
    decho '********** SKIPPING HEADER INSTALLATION BECAUSE CONFIG_TRIM_UNUSED_KSYMS=y *****'
else
    decho '********** PREPPING INITRAMFS HEADER DIR ***************************************'
    HOSTHDRDIR=$(realpath -s $BASEDIR/usr/src/linux-headers-$KERNEL)
    decho HOSTHDRDIR=$HOSTHDRDIR
    if [ -h $HOSTHDRDIR ]; then
        HOSTHDRDIR=$(realpath $HOSTHDRDIR)
        decho HOSTHDRDIR is a symlink pointing to $HOSTHDRDIR
        DESTHDRDIR=$TEMPDIR/initramfs/usr/src/$(basename $HOSTHDRDIR)
        decho DESTHDRDIR=$DESTHDRDIR
        $mkdir $(dirname $DESTHDRDIR) || cleanup 1
        $ln -s $(basename $HOSTHDRDIR) $TEMPDIR/initramfs/usr/src/linux-headers-$KERNEL || cleanup 1
    else
        DESTHDRDIR=$TEMPDIR/initramfs/usr/src/linux-headers-$KERNEL
        decho DESTHDRDIR=$DESTHDRDIR
        $mkdir $(dirname $DESTHDRDIR) || cleanup 1
    fi


    decho '********** INSTALLING HEADERS **************************************************'
    # Copy headers over, too
    #
    # NOTE: This is unneeded for boot, but needed if we want to use booting our
    #       initrd as the installation method for modules and headers (e.g.,
    #       modinject).
    #
    $cp -a $HOSTHDRDIR $DESTHDRDIR || cleanup 1
fi


# Pick a compressor
decho '********** PICKING A COMPRESSOR ************************************************'
# FIXME: Tried to add lz4, but after initially thinking it worked, I can't get
#        5.4 to boot with an lz4 compressed initrd... removed it for now.
fast_list="zstd gzip xz"
best_list="xz zstd gzip"
comp_cmd=
if [ ! -f $config ]; then
    echo "WARNING: kernel config $config missing, default to gzip compression"
    comp_cmd="gzip"
else
    case $COMPMODE in
        fast)
            comp_list=$fast_list
            ;;
        best)
            comp_list=$best_list
            ;;
        *)
            echo "WARNING: invalid COMPMODE $COMPMODE, using fast"
            comp_list=$fast_list
    esac
    for comp in $comp_list; do
        # check for binary
        which $comp >/dev/null || continue
        # check kernel config
        grep -q CONFIG_RD_${comp^^}=y $config || continue
        comp_cmd="$comp"
        break
    done
fi
if [ -z "$comp_cmd" ]; then
    comp_cmd="cat"
elif [ "$opt_verbose" != 0 ]; then
    comp_cmd+=" -v"
fi
case ${comp_cmd%% *} in
    lz4)
        comp_cmd+=" -l"
        ;;
    xz)
        comp_cmd+=" --check=crc32"
        ;;
esac
echo "Chose compressor: $comp_cmd"


# Create the compressed image
decho '********** CREATING COMPRESSED CPIO IMAGE **************************************'
pushd >/dev/null $TEMPDIR/initramfs &&
find . | $cpio -o -H newc | $comp_cmd > ../initramfs.img &&
popd >/dev/null || cleanup 1

rm -f $INITRAMFS_TARGET
$mv $TEMPDIR/initramfs.img $INITRAMFS_TARGET

echo "Done; initramfs is $(du -h $INITRAMFS_TARGET | awk '{print $1}')."
echo
cleanup 0
