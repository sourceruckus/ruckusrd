<h1>NAME</h1>
<p>Ruckusrd - manual page for Ruckusrd 0.21.0</p>
<h1>DESCRIPTION</h1>
<p>RuckusRD - a super awesome, yet simple, mkinitrd replacement
Copyright Â© 2012-2024 Michael D Labriola
&lt;veggiemike@sourceruckus.org&gt;</p>
<p>usage: ruckusrd OPTIONS &lt;out-initrd-image&gt;
&lt;kernel-version&gt;</p>
<dl>
<dt><strong>-h</strong>, <strong>--help</strong></dt>
<dd>
<p>Show this help message and exit.</p>
</dd>
<dt><strong>-V</strong>, <strong>--version</strong></dt>
<dd>
<p>Show version string and exit.</p>
</dd>
<dt><strong>-v</strong>, <strong>--verbose</strong></dt>
<dd>
<p>Show verbose output.</p>
</dd>
<dt><strong>-f</strong>, <strong>--force</strong></dt>
<dd>
<p>Force overwrite existing file.</p>
</dd>
<dt><strong>-b</strong>, <strong>--basedir</strong> BASEDIR</dt>
<dd>
<p>Use BASEDIR as prefix to all paths.</p>
</dd>
<dt><strong>-c</strong>, <strong>--compressor</strong> COMPMODE</dt>
<dd>
<p>Pick compressor mode. Valid options are 'best' and 'fast'. Default is
'fast'.</p>
</dd>
<dt><strong>-o</strong>, <strong>--options</strong> LINUXRCOPTS</dt>
<dd>
<p>Specifiy runtime options to pass to the linuxrc init script in the
generated initramfs.</p>
</dd>
<dt><strong>-U</strong>, <strong>--with-ucode</strong> UCODE_IMG</dt>
<dd>
<p>Include ucode.img in generated initramfs. Default is
<em>/boot/ucode.img</em></p>
</dd>
<dt><strong>-N</strong>, <strong>--no-ucode</strong></dt>
<dd>
<p>Do NOT append any microcode to the generated initramfs (probably only
useful for testing).</p>
</dd>
</dl>
<p>example: ruckusrd <em>/boot/myinitramfs.img</em> `uname
<strong>-r</strong>`</p>
<h1>SQUASHFS LAYERS</h1>
<p>As always, the default behavior of the <em>linuxrc</em> script will
be to assemble a traditional root filesystem and switch over to it.
However, it also supports a special squashfs layering mechanism for
quickly creating new systems.</p>
<p>If <strong>sqsh_layers=layer2:layer1</strong> is provided on the
kernel command line, <strong>layer1.sqsh</strong> will be mounted at
<em>/layer1</em>, <strong>layer2.sqsh</strong> at <em>/layer2</em>, etc.
These layers will then be used as the "lower layers" for an OverlayFS
mount. Note that OverlayFS stacks lower layers from right to left (i.e.,
<strong>layer2</strong> is stacked on top of
<strong>layer1</strong>).</p>
<p>The "upper layer" is for read-write functionality. Unless overriden
via other parameters, a speical <strong>upper</strong> directory on the
provided root device will be used.</p>
<p>After switching root, this will result in the rootdev being at
<strong>/mnt/root-true</strong> with each read-only squashfs layer being
mounted at <strong>/mnt/sqsh_layer-NAME</strong>. Since the upper layer
needs to be writable, the rootdev will be mounted read-write (unless
<strong>ram_layer</strong>, see <strong>BOOT</strong> PARAMETERS).</p>
<p>All the squashfs image files are expected to be on the root of the
specified root device (unless <strong>sqsh_layerdev</strong>, see
<strong>BOOT PARAMETERS</strong>).</p>
<h1>FIRMWARE</h1>
<p>Yah, do it</p>
<h1>MICROCODE</h1>
<p>And this, too</p>
<h1>BOOT PARAMETERS</h1>
<p>Initramfs created with <em>ruckusrd</em> will handle the following
kernel command line parameters, provided in groupings based on
use-case.</p>
<h2>Regular/Common</h2>
<dl>
<dt><strong>blacklist</strong>=<strong>MODULE</strong></dt>
<dd>
<p>Add the specified <strong>MODULE</strong> to the system's kernel
module blacklist file, to prevent it from being autoloaded by udev.</p>
</dd>
<dt><strong>init</strong>=<strong>INIT</strong></dt>
<dd>
<p>Provide path to alternate init binary, <strong>INIT</strong>.</p>
</dd>
<dt><strong>quiet</strong></dt>
<dd>
<p>Don't make any terminal output if you can help it. Most distros use
this as a default boot parameter as to not interupt graphical boot
screens.</p>
</dd>
<dt><strong>root</strong>=<strong>DEVSPEC</strong></dt>
<dd>
<p>The single most important boot parameter! Specify where the root
filesystem is located, so we can use it! <strong>DEVSPEC can be a plain
device name, or you</strong> can specify a filesystem label
(<em>LABEL</em>=), filesystem UUID (<em>UUID</em>=), CD/DVD-ROM label
(<em>CDLABEL</em>=), or ZFS dataset (<em>ZFS</em>=).</p>
</dd>
<dt><strong>rootflags</strong>=<strong>FLAGS</strong></dt>
<dd>
<p>Specify extra <strong>FLAGS</strong> for mounting the root
device.</p>
</dd>
<dt><strong>rootfstype</strong>=<strong>FSTYPE</strong></dt>
<dd>
<p>Explicitly state the <strong>FSTYPE</strong> of the root device,
instead of auto-detecting.</p>
</dd>
<dt><strong>rw</strong></dt>
<dd>
<p>Leave the sysroot mounted read-write before handing off to sysroot's
init system. Most init systems expect sysroot to be read-only when they
start (and that's the default behavior of <em>ruckusrd</em> initramfs),
but sometimes you need this.</p>
</dd>
<dt><strong>verbose</strong></dt>
<dd>
<p>Make the <em>linuxrc</em> script be extra verbose, the exact opposite
of <strong>quiet</strong>. This is <em>very</em> noisy, so be
warned.</p>
</dd>
</dl>
<h2>Squashfs Layers</h2>
<dl>
<dt><strong>overlayflags</strong>=<strong>FLAGS</strong></dt>
<dd>
<p>Specify extra <strong>FLAGS</strong> for mounting the Overlay File
System.</p>
</dd>
<dt><strong>ram_layer</strong>=<strong>SIZE</strong></dt>
<dd>
<p>Use RAM for the upper layer. This will result in tmpfs of the
requested <strong>SIZE</strong> mounted at <strong>/upper</strong>. Any
valid value for the tmpfs <strong>size</strong> option can be specified
(e.g., 2G, 50%). Since rootdev will no longer need to be writable, it
will be mounted read-only.</p>
</dd>
<dt><strong>root_true_rw</strong></dt>
<dd>
<p>Similar to <strong>rw</strong>, leave the root-true device mounted
read-write before handing off to sysroot's init system.</p>
</dd>
<dt><strong>sqsh_layerdev</strong>=<strong>DEV</strong></dt>
<dd>
<p>Use <strong>DEV</strong> as an alternate device for locating the sqsh
layers. <strong>DEV</strong> will be mounted read-only. This is
primarily for supporting sharing of a read-only device between multiple
virtual machines which all have their own dedicated rootdev for the
upper layer.</p>
</dd>
</dl>
<p><em>NOTE:</em> This causes us to look at rootdev AND THEN
sqsh_layerdev for named layers. This way, we'll be able to have shared
base images w/ host-specific extra layers. Otherwise, if a host with
lots of changes decides to create a new layer, it would have to have
write access to sqsh_layerdev (which it almost definately does not
have).</p>
<p><em>NOTE:</em> This option cannot be used along with
<strong>to_ram</strong> because... why would you do that? The point of
<strong>to_ram</strong> is allowing for removal of the root device after
boot. To use <strong>to_ram</strong> with a separate sqshdev would work
in theory, as long as we copy layers from the correct path, but how many
different pieces of removable media are really going to require at
bootup? More than 1? I see no use-case for that.</p>
<dl>
<dt><strong>sqsh_layerdir</strong>=<strong>DIR</strong></dt>
<dd>
<p>Use <strong>DIR</strong> as the relative path to the images provided
via <strong>sqsh_layers</strong>. This is so that the layers can be
located somewhere other than at the root of the specified device.</p>
</dd>
<dt><strong>sqsh_layers</strong>=<strong>SQSH_LAYERS</strong></dt>
<dd>
<p>Specifiy tiered list of lower layers to be used along with a
read-write upper layer (on the <strong>root</strong> device) in an
OverlayFS mount to be userd as the sysroot. See <strong>SQUASHFS
LAYERS</strong> for more details.</p>
</dd>
<dt><strong>sqshfstype</strong>=<strong>FSTYPE</strong></dt>
<dd>
<p>Explicitly state the <strong>FSTYPE</strong> of the
<strong>sqsh_layerdev</strong> device, instead of auto-detecting.</p>
</dd>
<dt><strong>to_ram</strong></dt>
<dd>
<p>Used in conjunction with <strong>ram_layer</strong>, causes the
entire contents of the rootdev to be loaded into RAM, so you can safely
unmount the root device (i.e., if it's a USB stick or DVD-ROM).
Obviously, this requires a small root dev or a large ammount of RAM...
or both.</p>
</dd>
</dl>
<h2>Initramfs Debugging</h2>
<dl>
<dt><strong>shell</strong></dt>
<dd>
<p>Drop to a shell as soon as <em>linuxrc</em> script starts, before
doing anything, not even udev rule creation. As a regular user, you
never want this. It's convenient for testing and development of the
<em>linuxrc</em> script, though. In fact, there are more
<strong>shell_*</strong> breakpoints scattered through
<em>linuxrc</em>... go grep for them.</p>
</dd>
</dl>
<h2>Maintenance</h2>
<dl>
<dt><strong>maint</strong></dt>
<dd>
<p>Drop to a maintenance shell AFTER assembling <em>/sysroot</em>, just
prior handing off control to <em>/sysroot</em>'s init system. When this
shell exits, sysroot boot continues. This gives you a convenient way to
interrupt boot to fix something silly, then continue booting w/out even
having to fully reboot.</p>
</dd>
</dl>
<h2>Other Super Cool Options</h2>
<dl>
<dt><strong>firstboot</strong></dt>
<dd>
<p>Prior to handing control over to sysroot, run our embedded
<em>firstboot_wizard</em> to pre-configure a bunch of things for the
first boot of a new system. Even if <strong>firstboot</strong> is
specified, if <em>.ruckusrd_firstboot_done</em> exists at the root of
the sysroot filesystem, <em>firstboot_wizard</em> will be skipped.</p>
</dd>
<dt><strong>fwdev</strong>=<strong>FWDEV</strong></dt>
<dd>
<p>Specify a device containing <em>fw.sqsh</em>. If found, this squashfs
image is mounted on <em>/lib/firmware</em> to provide firmware to
modules loaded during the initramrd stage (e.g., video cards, ethernet
cards). Not only does this ensure that all the firmware needed for any
potentially loaded modules (i.e., if you want networking during a
<strong>maint</strong> session) is present, it also makes updating
firmware independent of the initrd or kernel upgrade process. A giant
<em>fw.sqsh</em> is built in <em>ruckusrd/subprojects/fw.sqsh</em> out
of ALL the latest firmware, but isn't installed (it is quite large).
Alternatively, you can create a machine-specific set of firmware with
<strong>firmwarenator</strong>(1).</p>
</dd>
<dt><strong>hoststamp</strong></dt>
<dd>
<p>Append a timestamp to system hostname. Probably only desired when
using <strong>ram_layer</strong> and/or <strong>to_ram</strong> to boot
a bunch of systems from a common image (i.e., an installer or
live-disk).</p>
</dd>
<dt><strong>initramsys</strong></dt>
<dd>
<p>Completely ignore sysroot. Invoke the initramfs's init instead, and
you've got a fully functional embedded system (complete with networking
and multiple TTYs to login on) w/out any root device.</p>
</dd>
<dt><strong>modinject</strong></dt>
<dd>
<p>Inject kernel modules (and kernel header files) from the initramfs
into the sysroot. This ensures that the same modules exist post bootup
that exist during initrd, and removes the requirement of installing
kernel modules prior to booting a new kernel.</p>
</dd>
</dl>
<h1>KERNEL COMMAND LINE EXAMPLES</h1>
<p>Regular system</p>
<p>root=/dev/sda1 quiet</p>
<p>Regular system w/ extra cool fun features</p>
<p>root=LABEL=rootishness quiet firstboot modinject
fwdev=LABEL=firmware</p>
<p>Squashfs layers, read-write upper on rootdev</p>
<p>root=/dev/sda1 sqsh_layers=extra:server:base</p>
<p>Squashfs layers, read-write upper on rootdev but sqsh_layers on
alternate read-only device</p>
<p>root=/dev/xvda1 sqsh_layerdev=/dev/xvdb1
sqsh_layers=extra:server:base</p>
<p>Squashfs layers, read-only rootdev, RAM upper layer</p>
<p>root=/dev/sda1 sqsh_layers=extra:server:base ram_layer=50%</p>
<p>Squashfs layers, unmounted/removable rootdev, RAM upper layer</p>
<p>root=/dev/sda1 sqsh_layers=extra:server:base ram_layer=50% to_ram</p>
<h1>FILES</h1>
<dl>
<dt><em>/etc/ruckusrd.conf</em></dt>
<dd>
<p>System-wide default config file.</p>
</dd>
<dt><em>~/.ruckusrd.conf</em></dt>
<dd>
<p>User config file, which is read last.</p>
</dd>
<dt><em>/boot/ucode.img</em></dt>
<dd>
<p>Default path to microcode image to be prepended to generated initrd
file.</p>
</dd>
<dt><em>/.ruckusrd_firstboot_done</em></dt>
<dd>
<p>Prevents <em>firstboot_wizard</em> from running even if
<strong>firstboot</strong> boot parameter was specified.</p>
</dd>
</dl>
<h1>SEE ALSO</h1>
<p><strong>firmwarenator</strong>(1),
<strong>microcodenator</strong>(1),
<strong>kernel-builder</strong>(1)</p>
