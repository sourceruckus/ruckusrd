-*- mode: outline -*-

* For 1.0.0

 - fix all the FIXMEs

 - documentation (html, man)

 - Maybe revamp command-line usage?

 - Maybe add checksum verification of sqsh_layers to linuxrc?  If anything's
   been modified, make a lot of noise and don't boot.

 - Add --with-system-{busybox,e2fsprogs,eudev,lvm2,mdadm,squashfs-tools}
   configure flags.


* For 0.x

 - Should prefix all our non-standard kernel commandline options w/
   ruckusrd.whatever.  Once we have config-file support, we should be able to
   keep it a bit less verbose, and this will guard us against accidentally
   using the same option as something in the kernel or systemd.  A couple
   should probably stay unprefixed (e.g., root=, quiet).

 - Tidy up  linuxrc output.  "quiet"  mode should  be silent to  match expected
   behavior in  most distros.  Perhaps  prefix each  output w/ "ruckusrd:  " or
   something  like that  to differentiate  our initramfs  messages from  kernel
   spew?

 - Once we've got microcodenator generating /boot/ruckusrd-ucode.img, we should
   do the same thing we're doing with firmware?  I seem to recall that ucode
   had to be the 1st thing seen by the kernel... so that might not work.

 - Consider adding a `ruckusonly` flag to linuxrc to invoke busybox's init
   instead of switching rootfs and invoking the normal system's init.  This
   would give us a more complete system (complete with multiple TTYs to login
   on) and opens the door for using a ruckusrd initramfs on it's own to
   facilitate installation on blank drives.

 - Once we've got our initrd acting as a kernel-installer (via modinject), we
   could also add code to do the new sqsh_layer prep and have it work as a full
   blown system installer.  Assuming the user has already created an upper
   layer device and specified it as root=whatever, we could automatically do
   the following:

   1. create new /etc/hostname
   2. create new /etc/mailname
   3. sed hostname and domain into /etc/postfix/main.cf
   4. create new /etc/machine-id
   5. remove /var/log/journal/*
   6. create new /etc/fstab
   7. clean out NetworkManager connections (maybe?)

   Of course, if we do that... it will really be distro specific.  So far, the
   things that would get tweaked are pretty generic... it might actually work
   in most distros.

   We could even go as far as creating logvol and EXT4 fs to match
   root=whatever if needed.  That would make installation via pre-existing
   squashfs image super duper trivial: 1) boot up off USB stick, pick "Install
   system" option in syslinux menu, either edit the kernel commandline to
   provide root=whatever, hostname, domainname, or add a couple prompts during
   boot.  Done.

   When installing on a blank system, we would also have to setup boot.
   Install syslinux (either for EFI or BIOS), install the kernel files, install
   the squashfs.img locally somewhere, etc.

 - Add zstd to initramfs?


* For 0.17

 - Add a linuxrc flag to disable loading of nonessential modules so we can get
   to a state where we can populate /lib/firmware and then load them.  We've
   got a chicken-and-the-egg problem regarding firmware detection.  Everything
   I've done so far assumes you can boot up a perfect system with all the
   appropriate firmware in place when modules load, so you can detect which
   files are needed for your particular hardware...  So where does this perfect
   system come from?  I essentually bootstrapped mine off a normal ubuntu 18.04
   install to get things started... but that's not very magestic.

   I tried providing all the firmware to the initramfs a while back, and it
   blew up.  I assumed it was too large or something as it was an extra 500M or
   so.  So, can we boot up to a pre-udev breakpoint and ask for firmware?
   Supply it via some other block device or something?  Can't use network to
   get it, because we might need firmware for that.

   For the record, the entire linux-firmware tree is 216M compressed w/ zstd
   and I CAN append that to the initrd and boot it up just fine.  However, that
   leaves me with an initrd that's 300M instead of 70M, and most of that is
   exactly the same regardless of kernel version.

   To create fw-all.img, from inside a linux-firmware git clone:

   find . -path ./.git\* -o -type f -print L | cpio -p --make-dir /scrap/fw-all/lib/firmware
   pushd /scrap/fw-all
   find . | cpio -o -H newc | zstd -T0 -10 > /scrap/fw-all.img
   popd

   Ok, the problem I remember looks like it's a syslinux efi limitation on
   total size of payload (kernal+initrd+whateverele), so on my laptop (where I
   need to do this) it doesn't work.  It works on a domU, but that's pointless
   because no hardware.

   New plan is to create a fw-all.sqsh file in /boot, mount it on /lib/firmware
   at 'shell' breakpoint, then go on our merry way.  To create the image:

   mksquashfs . /scrap/fw-all.sqsh -comp xz -e .git

   Yes.  This works.  In fact, it might work so well it could be an every boot
   thing completely replacing the "append fw.img to initrd" process...

   1. Break at 'shell'
   1.1. Mount the root dev
   1.2. Mount fw-all.sqsh on /lib/firmware
   1.3. Umount -l root dev
   1.4. exit
   2. Break at 'maint'
   2.1. Umount -l /lib/firmware
   2.2. exit

   That gives you the perfect situation post boot, where ALL the kernel modules
   are available pre-switchroot, and ALL the FIRMWARE is available as well.
   And the fw.img is seperate from the other kernel files.

   I can't see any reason to do this any differently.  I suppose we can keep
   firmwarenator around along with my patch to print out firmware loading
   messages for the case where we want to create a smaller initrd w/out extra
   fw.sqsh...  but I don't really see myself using it.

   Hmmm...  how do we figure out what the boot device was so we can remount it
   to get at the fw.sqsh file?  I can do it by hand because I already KNOW what
   device it's on.  fwdev= arg that doesn't use the udev device detection?
   Just straight up fwdev=/dev/nvme0n1p1 and expect fw.sqsh to be sitting at
   its root?
   
 - We need to get firmware loaded up during the initramfs stage of boot.  This
   is because now that we include all the kernel modules, udev will be able to
   load any module the kernel notices... and there are some that are going to
   require firmware to be present during load.

   For now, we've got the firmwarenator util that will create a fw.img file
   that can be appended to the initrd file pretty easily... but it would be
   nice if this was automaticly handled.

   Logistically annoying, but at least appending to the ruckusrd created
   initramfs sounds trivial:

   $ cat /boot/fw.img >> /boot/initrd-5.10.y.img

   That assumes that both fw.img and initrd.img use the same compressor.  If
   that's not the case, it can be remedied like this:

   $ zstdcat /boot/fw.img | gzip >> /boot/initrd-5.4.y.img

   We should have kernel_tar's installation script do that automatically if
   /boot/ruckusrd-fw.img exists.  I think we can simply use file to
   detect/correct mismatched compressors.

 - Add script to help create microcode.img.  Unlike the firmware.img
   generation, we probably can't assume that the kernel is already loading
   microcode propperly...  but really we only have 2 choices (intel/amd) so we
   could just detect cpu type and include everything.

   Maybe we should add linux-firmware, microcode, and regulatory.db repos as
   submodules here as well?  I was originally planning on creating my own
   linux-firmware-mdl repo, with helper scripts and submodules...  but it might
   be easier to just keep everything together here under one roof.

   NOTE: Also, once we've tested this, we should go disable the deprecated
         firmware loading methods in our kernel .configs.

   NOTE: Started this as microcodenator, but it's only half implemented.
         Finish it.

- Firmware/microcode should probably also get injected via modinject

- Microcode needs to really be in the initrd for early loading to work.  We'll
  still stick it in fw.sqsh as well, as that will get injected into the root
  filesystem to maintain consistency.

- Allow some dynamic device naming for fwdev= command line arg.  We need to be
  able to do it prior to module loading, so we can't do full-blown LVM or MDADM
  stuff... but we can probably do some block device querying for simple LABEL=
  support... right?  blkid -L ESP should work for my laptop.

- Our current ucode.img support is super convenient, but it's tied specific
  checkouts of the firmware and ucode repos to specific releases of ruckusrd...
  perhaps we can add a ruckusrd --update-firmware flag in the future to update
  those files w/out making a new release of ruckusrd?

  Also, what do the roles of firmwarenator and microcodenator become?  Small,
  machine-specific fw.img and ucode.img generation?  Maybe they should be used
  post-installation of ruckusrd to create/update fw.sqsh and ucode.img?
  Perhaps with --specific and --universal flags?


* Could happen in a stable release

 - I've added rsync and dropbear, and they both work.  However, something is
   wonky regarding uid detection in my maint shell.  Even after adding
   /etc/passwd and /etc/group (so id shows valid stuff), dropbear's call to
   either getuid() or getpwuid() in cli-runopts.c is failing.  I think this is
   forcing me to specify -i /.ssh/id_dropbear on the ssh command line to get
   key-based auth working (as well as specifying root@).

   Hmm... somewhere along the line I stopped needing to specify -i, but it's
   still complaining. odd.  Hm, it's if I login.  Adding /etc/nsswitch.conf
   doesn't help....

 - Pretty sure I broke out-of-tree building at some point... need to fix that.

 - Build something into the build system to fetch submodules when building from
   dist tarball.  Right now, you can really only build the subprojects via a
   git clone.  (This means our dist tarballs are currently useless, as we don't
   yet have --with-system-whatever flags...)
