-*- mode: outline -*-

* For 1.0.0

 - fix all the FIXMEs

 - documentation (html, man)

 - Maybe revamp command-line usage?

 - Maybe add checksum verification of sqsh_layers to linuxrc?  If anything's
   been modified, make a lot of noise and don't boot.

 - Add --with-system-{busybox,e2fsprogs,eudev,lvm2,mdadm,squashfs-tools}
   configure flags.


* For 0.x

 - Should prefix all our non-standard kernel commandline options w/
   ruckusrd.whatever.  Once we have config-file support, we should be able to
   keep it a bit less verbose, and this will guard us against accidentally
   using the same option as something in the kernel or systemd.  A couple
   should probably stay unprefixed (e.g., root=, quiet).

 - Tidy up  linuxrc output.  "quiet"  mode should  be silent to  match expected
   behavior in  most distros.  Perhaps  prefix each  output w/ "ruckusrd:  " or
   something  like that  to differentiate  our initramfs  messages from  kernel
   spew?

 - Once we've got microcodenator generating /boot/ruckusrd-ucode.img, we should
   do the same thing we're doing with firmware?  I seem to recall that ucode
   had to be the 1st thing seen by the kernel... so that might not work.

 - Consider adding a `ruckusonly` flag to linuxrc to invoke busybox's init
   instead of switching rootfs and invoking the normal system's init.  This
   would give us a more complete system (complete with multiple TTYs to login
   on) and opens the door for using a ruckusrd initramfs on it's own to
   facilitate installation on blank drives.

 - Once we've got our initrd acting as a kernel-installer (via modinject), we
   could also add code to do the new sqsh_layer prep and have it work as a full
   blown system installer.  Assuming the user has already created an upper
   layer device and specified it as root=whatever, we could automatically do
   the following:

   1. create new /etc/hostname
   2. create new /etc/mailname
   3. sed hostname and domain into /etc/postfix/main.cf
   4. create new /etc/machine-id
   5. remove /var/log/journal/*
   6. create new /etc/fstab
   7. clean out NetworkManager connections (maybe?)

   Of course, if we do that... it will really be distro specific.  So far, the
   things that would get tweaked are pretty generic... it might actually work
   in most distros.

   We could even go as far as creating logvol and EXT4 fs to match
   root=whatever if needed.  That would make installation via pre-existing
   squashfs image super duper trivial: 1) boot up off USB stick, pick "Install
   system" option in syslinux menu, either edit the kernel commandline to
   provide root=whatever, hostname, domainname, or add a couple prompts during
   boot.  Done.

   When installing on a blank system, we would also have to setup boot.
   Install syslinux (either for EFI or BIOS), install the kernel files, install
   the squashfs.img locally somewhere, etc.


* For 0.17

 - We need to get firmware loaded up during the initramfs stage of boot.  This
   is because now that we include all the kernel modules, udev will be able to
   load any module the kernel notices... and there are some that are going to
   require firmware to be present during load.

   For now, we've got the firmwarenator util that will create a fw.img file
   that can be appended to the initrd file pretty easily... but it would be
   nice if this was automaticly handled.

   Logistically annoying, but at least appending to the ruckusrd created
   initramfs sounds trivial:

   $ cat /boot/fw.img >> /boot/initrd-5.10.y.img

   That assumes that both fw.img and initrd.img use the same compressor.  If
   that's not the case, it can be remedied like this:

   $ zstdcat /boot/fw.img | gzip >> /boot/initrd-5.4.y.img

   We should have kernel_tar's installation script do that automatically if
   /boot/ruckusrd-fw.img exists.  I think we can simply use file to
   detect/correct mismatched compressors.


* Could happen in a stable release

 - Add script to help create microcode.img.  Unlike the firmware.img
   generation, we probably can't assume that the kernel is already loading
   microcode propperly...  but really we only have 2 choices (intel/amd) so we
   could just detect cpu type and include everything.

   Maybe we should add linux-firmware, microcode, and regulatory.db repos as
   submodules here as well?  I was originally planning on creating my own
   linux-firmware-mdl repo, with helper scripts and submodules...  but it might
   be easier to just keep everything together here under one roof.

   NOTE: Also, once we've tested this, we should go disable the deprecated
         firmware loading methods in our kernel .configs.

   NOTE: Started this as microcodenator, but it's only half implemented.
         Finish it.

 - I've added rsync and dropbear, and they both work.  However, something is
   wonky regarding uid detection in my maint shell.  Even after adding
   /etc/passwd and /etc/group (so id shows valid stuff), dropbear's call to
   either getuid() or getpwuid() in cli-runopts.c is failing.  I think this is
   forcing me to specify -i /.ssh/id_dropbear on the ssh command line to get
   key-based auth working (as well as specifying root@).

   Hmm... somewhere along the line I stopped needing to specify -i, but it's
   still complaining. odd.  Hm, it's if I login.  Adding /etc/nsswitch.conf
   doesn't help....

 - Pretty sure I broke out-of-tree building at some point... need to fix that.

 - Build something into the build system to fetch submodules when building from
   dist tarball.  Right now, you can really only build the subprojects via a
   git clone.  (This means our dist tarballs are currently useless, as we don't
   yet have --with-system-whatever flags...)
